<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  	<script>
  		if(top!=window){top.location=location.href;}
  	
    	var ginit_time = new Date().getTime();
 		var gend_time = 0;
    </script>
	     <title>setsockopt函数解析   - hustcsh的日志 - 网易博客</title>
	<meta name="Author" content="hustcsh,hustcsh">
	<meta name="Keywords" content="setsockopt函数解析  ,日志,hustcsh的博客,hustcsh,hustcsh,网易博客,网易,blog">
	<meta name="Description" content="&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;int setsockopt (&lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;&amp;nbsp; SOCKET s,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;&amp;nbsp; int level,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;&amp;nbsp; int optname,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;&amp;nbsp; const char FAR * optval,&amp;nbsp; &lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;&amp;nbsp; int optlen&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;);&lt;/P&gt;
&lt;P style=&quot;TEXT-INDENT: 2em&quot;&gt;The Windows Sockets setsockopt function sets a socket option.&lt;/P&gt;,hustcsh的日志,,hustcsh的网易博客">
    <meta http-equiv="Content-Type" content="text/html;charset=gbk"/>
<link rel="shortcut icon" href="http://b1.bst.126.net/1014000/style/common/favicon.ico" />
<script type="text/javascript">try{document.execCommand('BackgroundImageCache',false,true);}catch(e){}</script>
<link type="text/css" rel="stylesheet" href="/style/css/base/src/00-htc.css"/>

<link type="text/css" rel="stylesheet" href="http://b1.bst.126.net/1014000/style/css/base/core_1.css" />
<link type="text/css" rel="stylesheet" href="http://b1.bst.126.net/1014000/style/css/base/core_2.css" />
	

  <script type="text/javascript" src="http://b1.bst.126.net/1014000/style/css/fixed/fixedThemeInit.js"></script>  
<link type="text/css" rel="stylesheet" href="http://b1.bst.126.net/1014000/style/css/fixed/4013/o.css" id="_$$_link_layout"/>
<link type="text/css" rel="stylesheet" href="http://b1.bst.126.net/1014000/style/css/fixed/4013/s.css"  id="_$$_link_theme"/> 

 
<script type="text/JavaScript">
<!--//--><![CDATA[//><!--
var UD = {
     status       : 'prev',
     themeId      :  4013,
     hostId       :  105228771,
     visitorId    :  0,
     visitorIP	  :  '220.167.43.95',
     visitorAvatar:	 '',
     hostPath     : '/hustcsh',
     hostName     : 'hustcsh', 
     pageName     : 'prevBlogPerma',
     visitorRank  : '-100',
     visitorName  : '', 
     hostNickname : 'hustcsh',
     visitorNickname : '',
     commentRank  : -100,
     invitedRank  : 0,
     externHash   : '',
     hasAdminCircles : 'false',
     hostImgUrl   : 'http://ava.bimg.126.net/photo/ONfvKgumRkgQiFnyVZSkkA==/208854432719926193.jpg',
     themeFileId  : '-1255873220833',
     serverName   : 'blog.163.com',
     dataDigest	  : 'null',
     lastModifyTime : '',
     visitorUserType: [12,21,106],
     uuid			: '16dd56b4-23b3-4d9d-a793-e2711d0a6737',
     speedTest		: 0,
     migStat		: 3,
     isAudit		: true
};   

if(UD.pageName == "prevHome" || UD.pageName == "editHome"){
	var date = new Date();
	date.setMinutes(0,0,0);
	UD.weatherGenTime = date.getTime();
}

//--><!]]>
</script>


<script type="text/javascript" src="http://b2.bst.126.net/1014000/js/gen/core1.js"></script>
<script type="text/javascript" src="http://b1.bst.126.net/1014000/js/gen/core_ext.js"></script>
<script type="text/javascript" src="http://b2.bst.126.net/1014000/js/gen/core2.js"></script>
<script type="text/javascript" src="http://b1.bst.126.net/1014000/js/gen/core3.js"></script>

<script type="text/javascript" src="http://b2.bst.126.net/1014000/js/gen/interface.js"></script>

<script type="text/javascript" src="http://b1.bst.126.net/1014000/js/gen/interface_ext.js"></script>


<script type="text/javascript" src="http://b1.bst.126.net/1014000/js/gen/blog.js"></script>
  </head> 
  <body lang="zh" id="blog-163-com">   
    <div id="tptlbr" style="display:none">&nbsp;</div>
    <div class="bggb" id="blog-163-com-body">
      <div class="innerlayer" id="_$$_inner_layer"><div class="g_p_none"><span class="a_a">&nbsp;</span></div>

<script language="JavaScript">
<!--//--><![CDATA[//><!--
 	if (NEBlog==undefined) 
		var NEBlog={};
		
	
	NEBlog.gPermalink_BlogCiters = [];
//--><!]]>
</script>


<div class="g_p_none">
  
  <!-- 单篇日志预览-内容 -->
  <div class="g_c_container g_p_hide " id="_$$_blog_perma" >
  <div id="layoutType" class="mdl_new ">
    <div class="mdl_new_main">
       <div class="mdl_new_mainc">
         <div>
<!-- 单篇日志预览-菜单 -->
         	<div style="display:block;padding-top:6px; border-bottom-width: 1px; border-bottom-style: dashed;" class="g_h_25 brd01">
			    	<a class="g_p_block g_w_45 g_p_right g_t_right n_ n33c g_t_14 c05" id="newerBlogLink" style="display:none;"><p class="g_p_right g_w_95 g_t_hide g_c_hand g_t_12" id="newerBlogTitle">&nbsp;</p></a>
			   		<a class="g_p_block g_w_45 g_p_left g_t_left n_ n34 g_t_14 c05" id="olderBlogLink" style="display:none;"><p class="g_w_95 g_t_hide g_c_hand g_p_left g_t_12" id="olderBlogTitle">&nbsp;</p></a>
			    <div class="g_p_clear g_t_space">&nbsp;</div>
			</div>	
	        <div class="mdl_new_diray">
		        <p class="g_p_center g_t_wrap g_t_left g_t_20 g_c_pdin c07" id="blogtitle_fks_083067084087081069082082094095085086084065086094081068085" style="margin:20px auto 10px;"><span style="font-family: '微软雅黑','黑体',Arial,Helvetica,Sans-Serif;">setsockopt函数解析  </span></p>
			    <div class="g_p_center g_t_right g_c_pdin g_h_20 c08" style="margin-bottom: 15px;">
			        <div class="g_p_left">
			        	<a id="aBelongClsfks_083067084087081069082082094095085086084065086094081068085" class="c05" href="#" onclick="NEBlog.gPermaLinkPage.updownMenu.openSameClass('fks_087070080081087067092095086095085086084065086094081068085', '技术学习');">技术学习</a>
			        	&nbsp;&nbsp;<span class="g_t_12 c08">2009-10-12 23:55</span>
			        	<span class="c08">&nbsp;&nbsp;阅读<nobr id="accessCount_fks_083067084087081069082082094095085086084065086094081068085">45</nobr>&nbsp;&nbsp;&nbsp;评论<nobr id="comCount_fks_083067084087081069082082094095085086084065086094081068085">0</nobr></span>
			        	<span class="c08">&nbsp;</span>
			        </div>
			        <div>字号：
			          <a id="bigfont" href="#" class="g_c_ul c05" onclick="NEBlog.gPermaLinkPage.updownMenu.changeFont('blogtext_fks_083067084087081069082082094095085086084065086094081068085', 1);return false;" style="font-size:12px;">大</a><span class="g_t_bold c07" id="bigfont_off" style="display:none;">大</span>&nbsp;
			          <a id="middlefont" href="#" class="g_c_ul c05" onclick="NEBlog.gPermaLinkPage.updownMenu.changeFont('blogtext_fks_083067084087081069082082094095085086084065086094081068085', 2);return false;" style="font-size:12px;">中</a><span class="g_t_bold c07" id="middlefont_off" style="display:none;">中</span>&nbsp;
			          <a id="smallfont" class="g_c_ul c05" href="#" onclick="NEBlog.gPermaLinkPage.updownMenu.changeFont('blogtext_fks_083067084087081069082082094095085086084065086094081068085', 3);return false;" style="display:none;font-size:12px;">小</a><span class="g_t_bold c07" id="smallfont_off" style="display:inline;">小</span>
			        </div>
		   		</div>
		   	    
				<div class="g_blog_list">
					<div class="g_t_center g_c_pdin g_p_center c07 content" id="blogtext_fks_083067084087081069082082094095085086084065086094081068085">
					  <div class="ns_content">
					   <P style="TEXT-INDENT: 2em">int setsockopt (</P>
<P style="TEXT-INDENT: 2em">&nbsp; SOCKET s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P style="TEXT-INDENT: 2em">&nbsp; int level,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P style="TEXT-INDENT: 2em">&nbsp; int optname,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P style="TEXT-INDENT: 2em">&nbsp; const char FAR * optval,&nbsp; </P>
<P style="TEXT-INDENT: 2em">&nbsp; int optlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P style="TEXT-INDENT: 2em">);</P>
<P style="TEXT-INDENT: 2em">The Windows Sockets setsockopt function sets a socket option.</P>
<P style="TEXT-INDENT: 2em">中文解释好像是：设置套接字的选项。</P>
<P style="TEXT-INDENT: 2em">先看如下代码：</P>
<P style="TEXT-INDENT: 2em">setsockopt(SockRaw,IPPROTO_IP,IP_HDRINCL,(char *)&amp;flag,sizeof(int))</P>
<P style="TEXT-INDENT: 2em">这里是设置SockRaw这个套接字的ip选项中的IP_HDRINCL</P>
<P style="TEXT-INDENT: 2em">参考以下资料：</P>
<P style="TEXT-INDENT: 2em">***************************************************************************************************</P>
<P style="TEXT-INDENT: 2em">Linux网络编程--8. 套接字选项&nbsp; </P>
<P style="TEXT-INDENT: 2em">有时候我们要控制套接字的行为(如修改缓冲区的大小),这个时候我们就要控制套接字的选项了.　</P>
<P style="TEXT-INDENT: 2em">8.1 getsockopt和setsockopt　</P>
<P style="TEXT-INDENT: 2em">int getsockopt(int sockfd,int level,int optname,void *optval,socklen_t *optlen) </P>
<P style="TEXT-INDENT: 2em">int setsockopt(int sockfd,int level,int optname,const void *optval,socklen_t *optlen) </P>
<P style="TEXT-INDENT: 2em">level指定控制套接字的层次.可以取三种值: </P>
<P style="TEXT-INDENT: 2em">1)SOL_SOCKET:通用套接字选项. </P>
<P style="TEXT-INDENT: 2em">2)IPPROTO_IP:IP选项. </P>
<P style="TEXT-INDENT: 2em">3)IPPROTO_TCP:TCP选项.　</P>
<P style="TEXT-INDENT: 2em">optname指定控制的方式(选项的名称),我们下面详细解释　</P>
<P style="TEXT-INDENT: 2em">optval获得或者是设置套接字选项.根据选项名称的数据类型进行转换　</P>
<P style="TEXT-INDENT: 2em">选项名称　　　　　　　　说明　　　　　　　　　　　　　　　　　　数据类型 </P>
<P style="TEXT-INDENT: 2em">======================================================================== </P>
<P style="TEXT-INDENT: 2em">　　　　　　　　　　　　SOL_SOCKET </P>
<P style="TEXT-INDENT: 2em">------------------------------------------------------------------------ </P>
<P style="TEXT-INDENT: 2em">SO_BROADCAST　　　　　　允许发送广播数据　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_DEBUG　　　　　　　　 允许调试　　　　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_DONTROUTE　　　　　 不查找路由　　　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_ERROR　　　　　　　　获得套接字错误　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_KEEPALIVE　　　　　　保持连接　　　　　　　　　　　　　　　　 int </P>
<P style="TEXT-INDENT: 2em">SO_LINGER　　　　　　　 延迟关闭连接　　　　　　　　　　　　　　struct linger </P>
<P style="TEXT-INDENT: 2em">SO_OOBINLINE　　　　　　带外数据放入正常数据流　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_RCVBUF　　　　　　　 接收缓冲区大小　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_SNDBUF　　　　　　　 发送缓冲区大小　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_RCVLOWAT　　　　　 &nbsp;接收缓冲区下限　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_SNDLOWAT　　　　　　发送缓冲区下限　　　　　　　　　　　　 int </P>
<P style="TEXT-INDENT: 2em">SO_RCVTIMEO　　　　　　 接收超时　　　　　　　　　　　　　　　　struct timeval </P>
<P style="TEXT-INDENT: 2em">SO_SNDTIMEO　　　　　　 发送超时　　　　　　　　　　　　　　　　struct timeval </P>
<P style="TEXT-INDENT: 2em">SO_REUSERADDR　　　　 允许重用本地地址和端口　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_TYPE　　　　　　　　 获得套接字类型　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">SO_BSDCOMPAT　　　　与BSD系统兼容　　　　　　　　　　　　　 int </P>
<P style="TEXT-INDENT: 2em">========================================================================== </P>
<P style="TEXT-INDENT: 2em">　　　　　　　　　　　　IPPROTO_IP </P>
<P style="TEXT-INDENT: 2em">-------------------------------------------------------------------------- </P>
<P style="TEXT-INDENT: 2em">IP_HDRINCL　　　　　　　在数据包中包含IP首部　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">IP_OPTINOS　　　　　　　IP首部选项　　　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">IP_TOS　　　　　　　　　服务类型 </P>
<P style="TEXT-INDENT: 2em">IP_TTL　　　　　　　　　生存时间　　　　　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">========================================================================== </P>
<P style="TEXT-INDENT: 2em">　　　　　　　　　　　　IPPRO_TCP </P>
<P style="TEXT-INDENT: 2em">-------------------------------------------------------------------------- </P>
<P style="TEXT-INDENT: 2em">TCP_MAXSEG　　　　　　　TCP最大数据段的大小　　　　　　　　　　 int </P>
<P style="TEXT-INDENT: 2em">TCP_NODELAY　　　　　　 不使用Nagle算法　　　　　　　　　　　　 int </P>
<P style="TEXT-INDENT: 2em">========================================================================= </P>
<P style="TEXT-INDENT: 2em">关于这些选项的详细情况请查看 Linux Programmer"s Manual　</P>
<P style="TEXT-INDENT: 2em">8.2 ioctl　</P>
<P style="TEXT-INDENT: 2em">ioctl可以控制所有的文件描述符的情况,这里介绍一下控制套接字的选项.　</P>
<P style="TEXT-INDENT: 2em">int ioctl(int fd,int req,...) </P>
<P style="TEXT-INDENT: 2em">　</P>
<P style="TEXT-INDENT: 2em">========================================================================== </P>
<P style="TEXT-INDENT: 2em">　　　　　　　　　　　　ioctl的控制选项 </P>
<P style="TEXT-INDENT: 2em">-------------------------------------------------------------------------- </P>
<P style="TEXT-INDENT: 2em">SIOCATMARK　　　　　　　是否到达带外标记　　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">FIOASYNC　　　　　　　　 异步输入/输出标志　　　　　　　　　　　 int </P>
<P style="TEXT-INDENT: 2em">FIONREAD　　　　　　　　 缓冲区可读的字节数　　　　　　　　　　　int </P>
<P style="TEXT-INDENT: 2em">========================================================================== </P>
<P style="TEXT-INDENT: 2em"><FONT size=3>有时候我们要控制套接字的行为(如修改缓冲区的大小),这个时候我们就要控制套接字的选项了.</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>获得套接口选项：</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>int getsockopt ( int sockfd, int level, int optname, void * optval, socklen_t *opteln )</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>置套接口选项： <BR>&nbsp;int setsockopt ( int sockfd, int level, int optname, const void * optval, socklen_t *opteln ) </FONT></P><FONT size=4>
<P style="TEXT-INDENT: 2em"><BR><FONT size=3>&nbsp;sockfd(套接字): 指向一个打开的套接口描述字 <BR>&nbsp;level:(级别)： 指定选项代码的类型。 <BR>SOL_SOCKET: 基本套接口&nbsp; <BR>IPPROTO_IP: IPv4套接口&nbsp; <BR>IPPROTO_IPV6: IPv6套接口&nbsp; <BR>IPPROTO_TCP: TCP套接口&nbsp; <BR>optname(选项名)： 选项名称&nbsp; <BR>optval(选项值): 是一个指向变量的指针 类型：整形，套接口结构， 其他结构类型:linger{}, timeval{ }&nbsp; <BR>optlen(选项长度) ：optval 的大小&nbsp; <BR>返回值：标志打开或关闭某个特征的二进制选项</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>SOL_SOCKET&nbsp; <BR>------------------------------------------------------------------------&nbsp; <BR>SO_BROADCAST 允许发送广播数据 int&nbsp; <BR>适用於 UDP socket。其意义是允许 UDP socket 「广播」（broadcast）讯息到网路上。 <BR>SO_DEBUG 允许调试 int&nbsp; <BR>SO_DONTROUTE 不查找路由 int&nbsp; <BR>SO_ERROR 获得套接字错误 int&nbsp; <BR>SO_KEEPALIVE 保持连接 int&nbsp; <BR>检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。 设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方 发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况： 对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。 对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。 对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到 一个响应。在发出第一个探测分节11分钟15秒后若仍无响应就放弃。套接口的待处理错 误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不 可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为 EHOSTUNREACH。&nbsp; </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>SO_DONTLINGER 若为真，则SO_LINGER选项被禁止。 <BR>SO_LINGER 延迟关闭连接 struct linger&nbsp; <BR>上面这两个选项影响close行为 <BR>选项 间隔 关闭方式 等待关闭与否 <BR>SO_DONTLINGER 不关心 优雅 否 <BR>SO_LINGER 零 强制 否 <BR>SO_LINGER 非零 优雅 是 <BR>若设置了SO_LINGER（亦即linger结构中的l_on<wbr>off域设为非零，参见2.4，4.1.7和4.1.21各节），并设置了零超时间隔，则closesocket()不被阻塞立即执行，不论是否有排队数据未发送或未被确认。这种关闭方式称为“强制”或“失效”关闭，因为套接口的虚电路立即被复位，且丢失了未发送的数据。在远端的recv()调用将以WSAECONNRESET出错。 <BR>若设置了SO_LINGER并确定了非零的超时间隔，则closesocket()调用阻塞进程，直到所剩数据发送完毕或超时。这种关闭称为“优雅的”关闭。请注意如果套接口置为非阻塞且SO_LINGER设为非零超时，则closesocket()调用将以WSAEWOULDBLOCK错误返回。 <BR>若在一个流类套接口上设置了SO_DONTLINGER（也就是说将linger结构的l_on<wbr>off域设为零；参见2.4，4.1.7，4.1.21节），则closesocket()调用立即返回。但是，如果可能，排队的数据将在套接口关闭前发送。请注意，在这种情况下WINDOWS套接口实现将在一段不确定的时间内保留套接口以及其他资源，这对于想用所以套接口的应用程序来说有一定影响。 <BR>SO_OOBINLINE 带外数据放入正常数据流,在普通数据流中接收带外数据 int&nbsp; <BR>SO_RCVBUF 接收缓冲区大小 int&nbsp; <BR>设置接收缓冲区的保留大小 <BR>与 SO_MAX_MSG_SIZE 或TCP滑动窗口无关，如果一般发送的包很大很频繁，那么使用这个选项 <BR>SO_SNDBUF 发送缓冲区大小 int&nbsp; <BR>设置发送缓冲区的保留大小 <BR>与 SO_MAX_MSG_SIZE 或TCP滑动窗口无关，如果一般发送的包很大很频繁，那么使用这个选项 <BR>每个套接口都有一个发送缓冲区和一个接收缓冲区。 接收缓冲区被TCP和UDP用来将接收到的数据一直保存到由应用进程来读。 TCP：TCP通告另一端的窗口大小。 TCP套接口接收缓冲区不可能溢出，因为对方不允许发出超过所通告窗口大小的数据。 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过宙口大小的数据，则接 收方TCP将丢弃它。 UDP：当接收到的数据报装不进套接口接收缓冲区时，此数据报就被丢弃。UDP是没有 流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的UDP丢弃数据报。 <BR>SO_RCVLOWAT 接收缓冲区下限 int&nbsp; <BR>SO_SNDLOWAT 发送缓冲区下限 int&nbsp; <BR>每个套接口都有一个接收低潮限度和一个发送低潮限度。它们是函数selectt使用的， 接收低潮限度是让select返回“可读”而在套接口接收缓冲区中必须有的数据总量。 ――对于一个TCP或UDP套接口，此值缺省为1。发送低潮限度是让select返回“可写” 而在套接口发送缓冲区中必须有的可用空间。对于TCP套接口，此值常缺省为2048。 对于UDP使用低潮限度， 由于其发送缓冲区中可用空间的字节数是从不变化的，只要 UDP套接口发送缓冲区大小大于套接口的低潮限度，这样的UDP套接口就总是可写的。 UDP没有发送缓冲区，只有发送缓冲区的大小。 <BR>SO_RCVTIMEO 接收超时 struct timeval&nbsp; <BR>SO_SNDTIMEO 发送超时 struct timeval&nbsp; <BR>SO_REUSERADDR 允许重用本地地址和端口 int&nbsp; <BR>充许绑定已被使用的地址（或端口号），可以参考bind的man <BR>SO_EXCLUSIVEADDRUSE <BR>独占模式使用端口,就是不充许和其它程序使用SO_REUSEADDR共享的使用某一端口。 <BR>在确定多重绑定使用谁的时候，根据一条原则是谁的指定最明确则将包递交给谁，而且没有权限之分，也就是说低级权限的用户是可以重绑定在高级权限如服务启动的端口上的,这是非常重大的一个安全隐患, <BR>如果不想让自己程序被监听，那么使用这个选项 <BR>SO_TYPE 获得套接字类型 int&nbsp; <BR>SO_BSDCOMPAT 与BSD系统兼容 int&nbsp; </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>IPPROTO_IP&nbsp; <BR>--------------------------------------------------------------------------&nbsp; <BR>IP_HDRINCL 在数据包中包含IP首部 int&nbsp; <BR>&nbsp;&nbsp; 这个选项常用于黑客技术中，隐藏自己的IP地址 </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>IP_OPTINOS IP首部选项 int&nbsp; <BR>IP_TOS 服务类型&nbsp; <BR>IP_TTL 生存时间 int&nbsp; </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>以下IPV4选项用于组播 <BR>IPv4 选项 数据类型 描 述 <BR>　　IP_ADD_MEMBERSHIP struct ip_mreq 加入到组播组中 <BR>　　IP_ROP_MEMBERSHIP struct ip_mreq 从组播组中退出 <BR>　　IP_MULTICAST_IF struct ip_mreq 指定提交组播报文的接口 <BR>　　IP_MULTICAST_TTL u_char 指定提交组播报文的TTL <BR>　　IP_MULTICAST_LOOP u_char 使组播报文环路有效或无效 <BR>在头文件中定义了ip_mreq结构： <BR>[co<wbr>de:1:63724de67f] <BR>struct ip_mreq { <BR>struct in_addr imr_multiaddr; /* IP multicast address of group */ <BR>struct in_addr imr_interface; /* local IP address of interface */ <BR>}; <BR>若进程要加入到一个组播组中，用soket的setsockopt()函数发送该选项。该选项类型是ip_mreq结构，它的第一个字段imr_multiaddr指定了组播组的地址，第二个字段imr_interface指定了接口的IPv4地址。 <BR>IP_DROP_MEMBERSHIP <BR>&nbsp;&nbsp;&nbsp; 该选项用来从某个组播组中退出。数据结构ip_mreq的使用方法与上面相同。 <BR>IP_MULTICAST_IF <BR>&nbsp;&nbsp;&nbsp; 该选项可以修改网络接口，在结构ip_mreq中定义新的接口。 <BR>IP_MULTICAST_TTL <BR>&nbsp;&nbsp;&nbsp; 设置组播报文的数据包的TTL（生存时间）。默认值是1，表示数据包只能在本地的子网中传送。 <BR>IP_MULTICAST_LOOP <BR>&nbsp;&nbsp;&nbsp; 组播组中的成员自己也会收到它向本组发送的报文。这个选项用于选择是否激活这种状态。</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3></FONT>&nbsp;</P>
<P style="TEXT-INDENT: 2em"><FONT size=3>IPPRO_TCP&nbsp; <BR>--------------------------------------------------------------------------&nbsp; <BR>TCP_MAXSEG TCP最大数据段的大小 int&nbsp; <BR>获取或设置TCP连接的最大分节大小(MSS)。返回值是我们的TCP发送给另一端的最大 数据量，它常常就是由另一端用SYN分节通告的MSS，除非我们的TCP选择使用一个比 对方通告的MSS小些的值。如果此值在套接口连接之前取得，则返回值为未从另・―端 收到Mss选项的情况下所用的缺省值。小于此返回值的信可能真正用在连接上，因为譬 如说使用时间戳选项的话，它在每个分节上占用12字节的TCP选项容量。我们的TcP将 发送的每个分节的最大数据量也可在连接存活期内改变，但前提是TCP要支持路径MTU 发现功能。如果到对方的路径改变了，此值可上下调整。 </FONT></P>
<P style="TEXT-INDENT: 2em"><BR><FONT size=3>TCP_NODELAY 不使用Nagle算法 int&nbsp; </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>指定TCP开始发送保持存活探测分节前以秒为单位的连接空闲时间。缺省值至少必须为7200秒，即2小时。此选项仅在SO_KEPALIVEE套接口选项打开时才有效。 </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>TCP_NODELAY 和 TCP_CORK， <BR>这两个选项都对网络连接的行为具有重要的作用。许多UNIX系统都实现了TCP_NODELAY选项，但是，TCP_CORK则是Linux系统所独有的而且相对较新；它首先在内核版本2.4上得以实现。此外，其他UNIX系统版本也有功能类似的选项，值得注意的是，在某种由BSD派生的系统上的TCP_NOPUSH选项其实就是TCP_CORK的一部分具体实现。 <BR>TCP_NODELAY和TCP_CORK基本上控制了包的“Nagle化”，Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。John Nagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome ，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。 Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。 <BR>现在让我们假设某个应用程序发出了一个请求，希望发送小块数据。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。例如，当我们正在发送一个较短的请求并且等候较大的响应时，相关过载与传输的数据总量相比就会比较低，而且，如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY选项来完成，这样就禁用了Nagle算法。 <BR>另外一种情况则需要我们等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服务器。应用Nagle算法在这种情况下就会产生问题。但是，如果你正在发送大量数据，你可以设置TCP_CORK选项禁用Nagle化，其方式正好同TCP_NODELAY相反（TCP_CORK 和 TCP_NODELAY 是互相排斥的）。下面就让我们仔细分析下其工作原理。 <BR>假设应用程序使用sendfile()函数来转移大量数据。应用协议通常要求发送某些信息来预先解释数据，这些信息其实就是报头内容。典型情况下报头很小，而且套接字上设置了TCP_NODELAY。有报头的包将被立即传输，在某些情况下（取决于内部的包计数器），因为这个包成功地被对方收到后需要请求对方确认。这样，大量数据的传输就会被推迟而且产生了不必要的网络流量交换。 <BR>但是，如果我们在套接字上设置了TCP_CORK（可以比喻为在管道上插入“塞子”）选项，具有报头的包就会填补大量的数据，所有的数据都根据大小自动地通过包传输出去。当数据传输完成时，最好取消TCP_CORK 选项设置给连接“拔去塞子”以便任一部分的帧都能发送出去。这同“塞住”网络连接同等重要。 <BR>总而言之，如果你肯定能一起发送多个数据集合（例如HTTP响应的头和正文），那么我们建议你设置TCP_CORK选项，这样在这些数据之间不存在延迟。能极大地有益于WWW、FTP以及文件服务器的性能，同时也简化了你的工作。示例代码如下： </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>intfd, on = 1; <BR>… <BR>/* 此处是创建套接字等操作，出于篇幅的考虑省略*/ <BR>… <BR>setsockopt (fd, SOL_TCP, TCP_CORK, &amp;on, sizeof (on)); /* cork */ <BR>write (fd, …); <BR>fprintf (fd, …); <BR>sendfile (fd, …); <BR>write (fd, …); <BR>sendfile (fd, …); <BR>… <BR>on = 0; <BR>setsockopt (fd, SOL_TCP, TCP_CORK, &amp;on, sizeof (on)); /* 拔去塞子 */ </FONT></P>
<P style="TEXT-INDENT: 2em"><BR><FONT size=3>不幸的是，许多常用的程序并没有考虑到以上问题。例如，Eric Allman编写的sendmail就没有对其套接字设置任何选项。 </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>Apache HTTPD是因特网上最流行的Web服务器，它的所有套接字就都设置了TCP_NODELAY选项，而且其性能也深受大多数用户的满意。这是为什么呢？答案就在于实现的差别之上。由BSD衍生的TCP/IP协议栈（值得注意的是FreeBSD）在这种状况下的操作就不同。当在TCP_NODELAY 模式下提交大量小数据块传输时，大量信息将按照一次write()函数调用发送一块数据的方式发送出去。然而，因为负责请求交付确认的记数器是面向字节而非面向包（在Linux上）的，所以引入延迟的概率就降低了很多。结果仅仅和全部数据的大小有关系。而 Linux 在第一包到达之后就要求确认，FreeBSD则在进行如此操作之前会等待好几百个包。 </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>在Linux系统上，TCP_NODELAY的效果同习惯于BSD TCP/IP协议栈的开发者所期望的效果有很大不同，而且在Linux上的Apache性能表现也会更差些。其他在Linux上频繁采用TCP_NODELAY的应用程序也有同样的问题。 </FONT></P>
<P style="TEXT-INDENT: 2em"><BR><FONT size=3>TCP_DEFER_ACCEPT </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>我们首先考虑的第1个选项是TCP_DEFER_ACCEPT（这是Linux系统上的叫法，其他一些操作系统上也有同样的选项但使用不同的名字）。为了理解TCP_DEFER_ACCEPT选项的具体思想，我们有必要大致阐述一下典型的HTTP客户/服务器交互过程。请回想下TCP是如何与传输数据的目标建立连接的。在网络上，在分离的单元之间传输的信息称为IP包（或IP 数据报）。一个包总有一个携带服务信息的包头，包头用于内部协议的处理，并且它也可以携带数据负载。服务信息的典型例子就是一套所谓的标志，它把包标记代表TCP/IP协议栈内的特殊含义，例如收到包的成功确认等等。通常，在经过“标记”的包里携带负载是完全可能的，但有时，内部逻辑迫使TCP/IP协议栈发出只有包头的IP包。这些包经常会引发讨厌的网络延迟而且还增加了系统的负载，结果导致网络性能在整体上降低。 <BR>现在服务器创建了一个套接字同时等待连接。TCP/IP式的连接过程就是所谓“3次握手”。首先，客户程序发送一个设置SYN标志而且不带数据负载的TCP包（一个SYN包）。服务器则以发出带SYN/ACK标志的数据包（一个SYN/ACK包）作为刚才收到包的确认响应。客户随后发送一个ACK包确认收到了第2个包从而结束连接过程。在收到客户发来的这个SYN/ACK包之后，服务器会唤醒一个接收进程等待数据到达。当3次握手完成后，客户程序即开始把“有用的”的数据发送给服务器。通常，一个HTTP请求的量是很小的而且完全可以装到一个包里。但是，在以上的情况下，至少有4个包将用来进行双向传输，这样就增加了可观的延迟时间。此外，你还得注意到，在“有用的”数据被发送之前，接收方已经开始在等待信息了。 <BR>为了减轻这些问题所带来的影响，Linux（以及其他的一些操作系统）在其TCP实现中包括了TCP_DEFER_ACCEPT选项。它们设置在侦听套接字的服务器方，该选项命令内核不等待最后的ACK包而且在第1个真正有数据的包到达才初始化侦听进程。在发送SYN/ACK包之后，服务器就会等待客户程序发送含数据的IP包。现在，只需要在网络上传送3个包了，而且还显著降低了连接建立的延迟，对HTTP通信而言尤其如此。 <BR>这一选项在好些操作系统上都有相应的对等物。例如，在FreeBSD上，同样的行为可以用以下代码实现： </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>/* 为明晰起见，此处略去无关代码 */ <BR>struct accept_filter_arg af = { "dataready", "" }; <BR>setsockopt(s, SOL_SOCKET, SO_ACCEPTFILTER, &amp;af, sizeof(af)); <BR>这个特征在FreeBSD上叫做“接受过滤器”，而且具有多种用法。不过，在几乎所有的情况下其效果与TCP_DEFER_ACCEPT是一样的：服务器不等待最后的ACK包而仅仅等待携带数据负载的包。要了解该选项及其对高性能Web服务器的重要意义的更多信息请参考Apache文档上的有关内容。 <BR>就HTTP客户/服务器交互而言，有可能需要改变客户程序的行为。客户程序为什么要发送这种“无用的”ACK包呢？这是因为，TCP协议栈无法知道ACK包的状态。如果采用FTP而非HTTP，那么客户程序直到接收了FTP服务器提示的数据包之后才发送数据。在这种情况下，延迟的ACK将导致客户/服务器交互出现延迟。为了确定ACK是否必要，客户程序必须知道应用程序协议及其当前状态。这样，修改客户行为就成为必要了。 <BR>对Linux客户程序来说，我们还可以采用另一个选项，它也被叫做TCP_DEFER_ACCEPT。我们知道，套接字分成两种类型，侦听套接字和连接套接字，所以它们也各自具有相应的TCP选项集合。因此，经常同时采用的这两类选项却具有同样的名字也是完全可能的。在连接套接字上设置该选项以后，客户在收到一个SYN/ACK包之后就不再发送ACK包，而是等待用户程序的下一个发送数据请求；因此，服务器发送的包也就相应减少了。 </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>TCP_QUICKACK </FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>阻止因发送无用包而引发延迟的另一个方法是使用TCP_QUICKACK选项。这一选项与 TCP_DEFER_ACCEPT不同，它不但能用作管理连接建立过程而且在正常数据传输过程期间也可以使用。另外，它能在客户/服务器连接的任何一方设置。如果知道数据不久即将发送，那么推迟ACK包的发送就会派上用场，而且最好在那个携带数据的数据包上设置ACK 标志以便把网络负载减到最小。当发送方肯定数据将被立即发送（多个包）时，TCP_QUICKACK选项可以设置为0。对处于“连接”状态下的套接字该选项的缺省值是1，首次使用以后内核将把该选项立即复位为1（这是个一次性的选项）。 <BR>在某些情形下，发出ACK包则非常有用。ACK包将确认数据块的接收，而且，当下一块被处理时不至于引入延迟。这种数据传输模式对交互过程是相当典型的，因为此类情况下用户的输入时刻无法预测。在Linux系统上这就是缺省的套接字行为。 <BR>在上述情况下，客户程序在向服务器发送HTTP请求，而预先就知道请求包很短所以在连接建立之后就应该立即发送，这可谓HTTP的典型工作方式。既然没有必要发送一个纯粹的ACK包，所以设置TCP_QUICKACK为0以提高性能是完全可能的。在服务器方，这两种选项都只能在侦听套接字上设置一次。所有的套接字，也就是被接受呼叫间接创建的套接字则会继承原有套接字的所有选项。 <BR>通过TCP_CORK、TCP_DEFER_ACCEPT和TCP_QUICKACK选项的组合，参与每一HTTP交互的数据包数量将被降低到最小的可接受水平（根据TCP协议的要求和安全方面的考虑）。结果不仅是获得更快的数据传输和请求处理速度而且还使客户/服务器双向延迟实现了最小化。 </FONT></P>
<P style="TEXT-INDENT: 2em"><BR><FONT size=3>&nbsp;</FONT></P>
<P style="TEXT-INDENT: 2em"><FONT size=3>8.2 ioctl&nbsp; <BR>ioctl可以控制所有的文件描述符的情况,这里介绍一下控制套接字的选项.&nbsp; <BR>int ioctl(int fd,int req,...)&nbsp; <BR>==========================================================================&nbsp; <BR>ioctl的控制选项&nbsp; <BR>--------------------------------------------------------------------------&nbsp; <BR>SIOCATMARK 是否到达带外标记 int&nbsp; <BR>FIOASYNC 异步输入/输出标志 int&nbsp; <BR>FIONREAD 缓冲区可读的字节数 int&nbsp; <BR>==========================================================================&nbsp; <BR>详细的选项请用 man ioctl_list 查看.</FONT></P>
<P style="TEXT-INDENT: 2em"><A href="http://blog.csdn.net/inter999/archive/2008/12/18/3546896.aspx"><STRONG></STRONG></A></P></FONT>&nbsp;
<P style="TEXT-INDENT: 2em"><STRONG><FONT size=4>setsockopt参数详解</FONT></STRONG> </P>
<P style="TEXT-INDENT: 2em">1. 如果在已经处于 ESTABLISHED状态下的socket(一般由端口号和标志符区分）调用<BR>closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：<BR>BOOL bReuseaddr=TRUE;<BR>setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&amp;bReuseaddr,sizeof(BOOL)); </P>
<P style="TEXT-INDENT: 2em">2. 如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历<BR>TIME_WAIT的过程：<BR>BOOL&nbsp; bDontLinger = FALSE; <BR>setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&amp;bDontLinger,sizeof(BOOL)); </P>
<P style="TEXT-INDENT: 2em">3.在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：<BR>int nNetTimeout=1000;//1秒<BR>//发送时限<BR>setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(char *)&amp;nNetTimeout,sizeof(int));<BR>//接收时限<BR>setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(char *)&amp;nNetTimeout,sizeof(int)); </P>
<P style="TEXT-INDENT: 2em">4.在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节<BR>(异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据<BR>和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：<BR>// 接收缓冲区<BR>int nRecvBuf=32*1024;//设置为32K<BR>setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));<BR>//发送缓冲区<BR>int nSendBuf=32*1024;//设置为32K<BR>setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&amp;nSendBuf,sizeof(int)); </P>
<P style="TEXT-INDENT: 2em">5. 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响<BR>程序的性能：<BR>int nZero=0;<BR>setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(char *)&amp;nZero,sizeof(nZero)); </P>
<P style="TEXT-INDENT: 2em">6.同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)：<BR>int nZero=0;<BR>setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(char *)&amp;nZero,sizeof(int)); </P>
<P style="TEXT-INDENT: 2em">7.一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：<BR>BOOL&nbsp; bBroadcast=TRUE; <BR>setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&amp;bBroadcast,sizeof(BOOL)); </P>
<P style="TEXT-INDENT: 2em">8.在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可<BR>以设置connect()延时,直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的<BR>作用，在阻塞的函数调用中作用不大)<BR>BOOL bConditionalAccept=TRUE;<BR>setsockopt(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)&amp;bConditionalAccept,sizeof(BOOL)); </P>
<P style="TEXT-INDENT: 2em">9.如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket(),以前我们<BR>一般采取的措施是"从容关闭"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体<BR>应用的要求(即让没发完的数据发送出去后在关闭socket)？<BR>struct linger {<BR>&nbsp; u_short&nbsp;&nbsp;&nbsp; l_on<WBR>off;<BR>&nbsp; u_short&nbsp;&nbsp;&nbsp; l_linger;<BR>};<BR>linger m_sLinger;<BR>m_sLinger.l_on<WBR>off=1;//(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)<BR>// 如果m_sLinger.l_on<WBR>off=0;则功能和2.)作用相同;<BR>m_sLinger.l_linger=5;//(容许逗留的时间为5秒)<BR>setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)&amp;m_sLinger,sizeof(linger));<BR>Note:1.在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用;<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2.如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_on<WBR>off=0； </P>
<P style="TEXT-INDENT: 2em">10.还一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息：<BR>(前不久做过这个函数的测试，调式信息可以保存，包括socket建立时候的参数,采用的<BR>具体协议，以及出错的代码都可以记录下来）<BR>BOOL bDebug=TRUE;<BR>setsockopt(s,SOL_SOCKET,SO_DEBUG,(const char*)&amp;bDebug,sizeof(BOOL));</P>
					  </div>
					</div>
				</div>
	         </div>
             <div class="g_tab_btn00 bdb g_t_left" id="cssTabBar_fks_083067084087081069082082094095085086084065086094081068085">
             
						<div class="bdl" id="ShareDiv_fks_083067084087081069082082094095085086084065086094081068085"><a class="c05" href="#" onclick="NEBlog.gPermaLinkPage.updownMenu.upDownCities('fks_083067084087081069082082094095085086084065086094081068085','blog/10522877120099121155244.track','blog/static/10522877120099121155244');return false;" >引用(<nobr id="tbCount_fks_083067084087081069082082094095085086084065086094081068085">?</nobr>)<span class="n_ n32 g_p_none">&nbsp;</span></a></div>
						<div class="bdl" id="RecommendDiv_fks_083067084087081069082082094095085086084065086094081068085"><a class="c05 n_ n55" href="#" onclick="NEBlog.gPermaLinkPage.recommend();return false;" >推荐(<nobr id="recommendCount_fks_083067084087081069082082094095085086084065086094081068085">?</nobr>)<span class="n_ n32 g_p_none">&nbsp;</span></a></div>
						<div class="c08 bdl bdr">评论(<nobr id="comCountMid_fks_083067084087081069082082094095085086084065086094081068085">?</nobr>)</div>
					<div class="c08 bdl bdr last">阅读(<nobr id="accessCountMid_fks_083067084087081069082082094095085086084065086094081068085">?</nobr>)</div>

		    	<input id="openCom_fks_083067084087081069082082094095085086084065086094081068085" type="hidden" value="-1"/>
			    <input id="openShare_fks_083067084087081069082082094095085086084065086094081068085" type="hidden" value="-1"/>
			    <input id="selectedLayout" type="hidden" value="0"/>
			</div>
			<div id="share_fks_083067084087081069082082094095085086084065086094081068085" class="g_t_left" style="display:none;"></div>
			<div id="com_fks_083067084087081069082082094095085086084065086094081068085">
<!-- 单篇日志预览-菜单 -->
         	<div class="ns_links">
         	
			   		<p class="c05"><a class="c05" id="olderBlogLinkBottom" style="display:none;">上一篇：<span id="olderBlogTitleBottom">&nbsp;</span></a>
			    <div class="g_p_clear g_t_space">&nbsp;</div>
			    	<p class="c05"><a class="c05" id="newerBlogLinkBottom" style="display:none;">下一篇：<span id="newerBlogTitleBottom">&nbsp;</span></a>
			</div>
				<div id="blogReader_fks_083067084087081069082082094095085086084065086094081068085"></div>
				<div class="g_p_relative g_h_1"  style="display: block;">
	                <div class="ns_mtt c08 brd01" id="ComDiv_fks_083067084087081069082082094095085086084065086094081068085">评论</div>
	    			<div id="comPubContainer" style="display:none;"></div>
	  				<div id="comPub_fks_083067084087081069082082094095085086084065086094081068085" class="g_h_1 cmt-all"></div>	
	    			<div id="comShow_fks_083067084087081069082082094095085086084065086094081068085" class="cmt-all"></div>	
	  			 </div>
  			 </div>
          </div>
          
       </div>
	</div>
	<div class="mdl_new_side brd01">
		<div id="aboutMeBasic"></div>
	    <div id="recentBlogs"></div>
	    <div id="recentRecommendBlogs"></div>
		<div id="postsense"></div>
     </div>

   <div class="g_p_clear g_t_space">&nbsp;</div>
   </div>    
 </div>
</div>

<!-- 生成模块脚本 -->
<script language="JavaScript">
	function initPage(){
    	var _$$_blog_perma = new netease.ui.module.Module("日志",null,$("_$$_blog_perma"),null,"",{parent:"_$$_module_container_center"});
	}
</script>
</div>
<div class="wsy topbar" id="_$$_TopBar">
	<div class="g_menu_llk sep">
      <span id="sysmsgs" style="display:none;">
      	<div class="g_hom_sys">
			<div class="icn_arrow">&nbsp;</div>
			<div id="sysmsgsContent" class="g_hom_sys_cnt"></div>
			<a class="a-close" onclick="closeSysMsg();return false;">关闭</a>
		</div>
	  </span>
      <ul class="fl topbar2">
	      <li class="noline"><a href="http://www.163.com/?frompersonalbloghome" target="_blank">网易首页</a></li>
	      <li class="chose"><a id="$_topbarItmes" class="arrow" href="javascript:void(0);" onClick="toggleBlogItems(event);">网易博客</a>
	        <ol class="ch-list" id="blog_items" style="display:none" onClick="stopBubble(event);">
	          <li><a href="http://blog.163.com/?frompersonalbloghome" target="_blank">博客首页</a></li>
	          <li><a href="http://pp.blog.163.com/?frompersonalbloghome" target="_blank">博客拍拍</a></li>
	          <li><a href="http://blog.163.com/public/theme/?frompersonalbloghome" target="_blank">精美风格</a></li>
	          <li><a href="http://q.163.com/#home?frompersonalbloghome" target="_blank">博客圈子</a></li>
	          <li><a href="http://huodong.163.com/?frompersonalbloghome" target="_blank">博客活动</a></li>
	          	<li><a href="http://my.163.com/?frompersonalbloghome" target="_blank">娱乐中心</a></li>
	          <li><div class="line brd01"></div></li>
	          <li><a href="http://blog.163.com/findFriend.do?type=5?frompersonalbloghome" target="_blank">找 朋 友</a></li>
	          <li><a href="http://blog.163.com/clone/clone.html?frompersonalbloghome" target="_blank">博客复制</a></li>
	          <li><a href="http://blog.163.com/services/wapblog.html?frompersonalbloghome" target="_blank">手机博客</a></li>
	          <li><a href="http://blog.163.com/services/emsblog.html?frompersonalbloghome" target="_blank">短信写博</a></li>
	          <li><div class="line brd01"></div></li>
	          <li><a href="http://feedback.163.com/fb/add/?productId=1" target="_blank">意见反馈</a></li>
	          <li><div class="line brd01"></div></li>
	          <li style="background-image: none;"><a href="http://blog.163.com/services/all.html?frompersonalbloghome">更多&gt;&gt;</a></li>
	        </ol>
	      </li>
      </ul>
      <form id="rmndtplfm" method="get" action="/search"><input class="bd01" type="text" name="q" disabled="true" value="" id="rmndtplin"/><input type="hidden" name="t" value="blog"/>
      <a class="bd01" id="rmndtplsr" href="http://blog.163.com/search?frompersonalsearch" target="_blank">搜 索</a></form>
	</div>
    <div class="g_menu_rlk sep" id="_$$_TopBarRight">
    
    </div>
</div>
      <div class="bgtt wsy">
<div class="bg10 wsy" id="_$$_Top_Outer">
  <div class="bg11 ht wkg" id="_$$_Top_Inner">
    <div class="flash ht" id="_$$_Top_Flash"></div>
    <div class="logo" onclick="window.location.href='http://blog.163.com/login.html';return false;">&nbsp;</div>
    <div class="title" id="_$$_Top_Title">
    </div>
  </div>
</div>
<div class="bg20 wsy">
  <div class="bg21 hn c02 wkg advnav">
    <div class="wnl hn">&nbsp;</div>
    <div class="wnr hn">&nbsp;</div>
    <div class="wnc hn" style="position:relative; z-index:100;">
      <div class="hn g_menu_nv">
        <div class="hn item ">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/" onclick="">首页</a>
        </div>
        <div class="hn item seltag">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/blog/" onclick="">日志</a>
        </div>
        <div class="hn item ">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/album/" onclick="">相册</a>
        </div>
        <div class="hn item ">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/music/" onclick="">音乐</a>
        </div>
        <div class="hn item ">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/collection/" onclick="">收藏</a>
        </div>
        <div class="hn item ">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/friends/" onclick="">博友</a>
        </div>
        <div class="hn item ">
          <a hidefocus="true" href="http://hustcsh.blog.163.com/profile/" onclick="">关于我</a>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="bgtf wsy"><div class="bgtf_ hz wkg"><div class="wzl hz">&nbsp;</div><div class="wzr hz">&nbsp;</div><div class="wzc hz">&nbsp;</div></div></div>
<div class="bgmt wsy"><div class="bgmt_ hy wkg"><div class="wyl hy">&nbsp;</div><div class="wyr hy">&nbsp;</div><div class="wyc hy">&nbsp;</div></div></div>
<div class="bg40 wsy">
  <div class="bg41 wkg g_p_hide" id="_$$_module_container">
	  <div class="wml bgml g_p_fill">&nbsp;</div>
	  <div class="wmr bgmr g_p_fill">&nbsp;</div>
	  <div class="wml mtl">&nbsp;</div><div class="wml mbl">&nbsp;</div>
	  <div class="wmr mtr">&nbsp;</div><div class="wmr mbr">&nbsp;</div>
	  <div class="wmc"><div id="layout_ctrl" class="css_inr_1 innerLayout">
	    <div class="wql hm" id="_$$_module_container_left" index="0"></div>
	    <div class="wqc hm" index="1">
<!-- 封禁的提示 -->
<div id="_$_prohibit_user_content" style="display:none;border:1px solid #AAAAAA;background-color:#FFFFDC;margin:10px 10px 10px 150px;height:60px;width:610px;">
		<div style="text-align:left;margin:10px 0px 0px 10px">
		<img src="http://blog.163.com/style/common/exclamation.gif" style="margin:0px 10px 0px 20px;float:left"/>
		<span style="color:#575757;line-height:20px;">很抱歉，因为您在网易相册发布了违规信息，账号被屏蔽。被屏蔽期间他人无法访问您的相册。<br>
			去<a style="color:#0000FF;line-height:20px;text-decoration:underline;" target="_blank" href="http://help.163.com/07/0129/11/360I4UJQ007525K2.html">帮助中心</a>，了解如何重新恢复服务。</span></div>
</div>		    <div id="_$$_module_container_center"></div>
	    </div>
	    <div class="wqr hm" id="_$$_module_container_right" index="2"></div>
	    <div class="g_p_clear">&nbsp;</div>
	  </div></div>
  </div>        
</div>
<div class="bgmf wsy"><div class="bgmf_ hx wkg"><div class="wxl hx">&nbsp;</div><div class="wxr hx">&nbsp;</div><div class="wxc hx">&nbsp;</div></div></div>
<div class="bg50 wsy">
  <div class="bg51 hf wkg c10">
    <div class="g_menu_bt fmgtp">
      <a target="_blank" href="http://corp.163.com/index_gb.html">公司简介</a><span>-</span>
      <a target="_blank" href="http://gb.corp.163.com/gb/contactus.html">联系方法</a><span>-</span>
      <a target="_blank" href="http://corp.163.com/gb/job/job.html">招聘信息</a><span>-</span>
      <a target="_blank" href="http://help.163.com/?b13abk1">客户服务</a><span>-</span>
      <a target="_blank" href="http://corp.163.com/gb/legal/legal.html">相关法律</a><span>-</span>
      <a href="http://jz.163.com" >互动营销</a><span>-</span>
      	  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://hustcsh.blog.163.com/rss/">
	      <a target="_blank" href="http://hustcsh.blog.163.com/rss/" class="p_ p0">&nbsp;</a>
    </div>
    <div>网易公司版权所有 &copy;1997-2009</div>
  </div>
</div>
      </div>
    </div>
    <div id="_$$_outer_layer"></div>
    <div class="g_p_none">
	  <input type="hidden" id="$_oppoPageUrlForLogin" value="/hustcsh/blog/static/10522877120099121155244/edit/"/>
    </div>
  <script language="JavaScript">     
  	function initUD(){
       UD.body=$("_$$_inner_layer");
       UD.layer=$("_$$_outer_layer");
       UD.window=$("blog-163-com-body");
       UD.bar=$("theme_selector_pointer");
     }
  </script>
   
<script language="JavaScript">
// <![CDATA[
     var g_urlPrefix="";
     function g_initCommon(){
         var _arr = ["rmdtpxt","rmdtplgn"];
         for (var i=_arr.length-1;i>=0;i--){
              _o = $(_arr[i]);
              if(i==0)_o && (_o.onclick=function(){exitAfterLogged();return false;});
              else if(i==1)_o && (_o.onclick=function(){showLoginDlg('blog.163.com');return false;});
         }
         topFromUrsLogin();
     } 
	function g_initUtil(){
		TopSearch.init();
	}
// ]]>
</script>

<style type="text/css">
<!--/*--><![CDATA[/*><!--*/
#messageZone {top:0px; right:20px; background:#ffffae; width:100px; position:fixed!important;
	position:absolute;font-family: Arial,Helvetica,sans-serif; padding:4px;font-size:12px;}
/*]]>*/-->
</style>

<script type='text/javascript' src='http://b.bst.126.net/js/utils/InfoAlertPad.js?1'></script>
 
  
  <script language="javascript">  
  function initAll(){
  	try{  		
  		initUD();
  		g_initCommon();
  		initFlash(0);  		
		  showPageTopBar({serverName:'blog.163.com',serverHostName:'blog.163.com'});
		initPage();
  		window.setTimeout("g_initUtil();",3000);
  		
  		//顶部博客子菜单的显示
  		Event.observe(document.body,'click',hideBlogItems);
  		
  		//主题风格需要做的事情
  		if(typeof _$$_initFixedTheme == 'function'){
  			_$$_initFixedTheme(4013);
  		}
 	 }catch(e){}
  }
  initAll();
  </script>
 

	<script language="JavaScript">
			function onVisitorInfoLoad(_p){	
				var _s = $('visitorInfoJs').readyState;
				if (_p && _s!='loaded'&&_s!='complete') return;
				
				gLoadPermaLink(1, 'prev', 'fks_083067084087081069082082094095085086084065086094081068085', 20, -100, 
					'setsockopt函数解析  ', 'blog/static/10522877120099121155244', '10522877120099121155244', 'http://q.163.com', 
					0, 1,	'off', '1255363703790'
);
					
				topFromUrsLogin();
			}		
		  			  			  	
	  		var ver = new Date().getTime();
	  		var setNone163Cookie = getUrlParam("setNone163Cookie");
	  		var setCookieStr = ""
	  		if(setNone163Cookie)
	  		   setCookieStr = "&setNone163Cookie="+setNone163Cookie;
	  		document.write('<script type="text/javascript" onreadystatechange="onVisitorInfoLoad(true);" onload="onVisitorInfoLoad();" id="visitorInfoJs" src="http://blog.163.com/js/static/visitorInfo.js?host=hustcsh&mode=prev&channel=blog&blogId=fks_083067084087081069082082094095085086084065086094081068085&pubTime=1255362924004&v=' + ver + setCookieStr+'"></'+'script>');
  	</script>
		
  
  </body>
</html>
