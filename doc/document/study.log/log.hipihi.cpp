1、上传成功之后，清楚编辑历史的标记
2、



	
17402427859830163 大卷包小卷
68261982421037620 小卷包大卷
35210743047301751 leizhenzi
54279171521758437 dididada
24802745846699607 jane0550
21230072751395385 happytest2

内网数据库：
58159105181734908 leizhenzi


sizeof(irr::scene::PatchBinData)=57081

jdbc.url=jdbc:mysql://192.168.0.40:3306/hy_hiv2?characterEncoding=utf8
jdbc.username=hiv2
jdbc.password=hiv2Password

剪彩仪式副空间：pid=(-8464,29216,id=1914756848) type=1001 dup=0, count=1	
login --id=16600 --host=192.168.0.43 --port=20000
autosendmsg --id=100,101,102,103,104,105,106,107,108,109,110,200,300,400,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,45,44,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70 --interval=0.5 vvvvvvvvvv

((*(OSLib::MemoryDataStream*)(&*pMsg))).m_pData

*(int*)((char*)(((*(OSLib::MemoryDataStream*)(&*pMsg))).m_pData) + sizeof(Net::Message::FixedHeader))

ldconfig `pwd`

查看错误号，在调试状态下面输入到查看窗口可以看到
wangdongming(王东明 - 葫芦四娃) 10:40:45
@err,hr



linux cdt 调试的时候，需要添加一个环境变量 LD_LIBRARY_PATH
${env_var:LD_LIBRARY_PATH};${workspace_loc:/hconnectserver}/../lib/Debug
	
	

idc2先登录 root@202.150.215.144 pwd:yog2st$@@
后面再登录：ssh root@10.192.21.10

无线网密码：issue

开发服务器：
10.192.0.43
root password: pass_43!hi
weizili：111111
pass_40!hi
pass_42!hi
pass_43!hi
pass_44!hi

软件
\\10.192.0.7
\\10.192.3.153

YOG server:
202.150.215.3
root
yog2zx$!!





v2
218.240.13.24		->	10.192.1.90		int#ba95e9c378a2 --> v2E3736DE602D8 heda#136ACA52C6D6
218.240.13.24  ssh port=2211 10.192.2.11	root/db#r3434asd2
218.240.13.20:80	->	10.192.2.11:80
su - v2
~/cpp/target

scp *.tar.gz root@218.240.13.24:/home/v2/cpp
	
./sshpass -p v2E3736DE602D8 scp server v2@v2.hipihi.com:/home/v2/test/tcp
/home/weizili/sshpass -p v2E3736DE602D8 scp server v2@v2.hipihi.com:/home/v2/test/tcp  








v2-b

最新的测试服务器组为v2-b,已完成配置安装，详细参考部署图

新增服务器
218.240.13.5 --> 10.192.2.4  root/com#b47da8611ff9 v2/v2E3736DE602D8
    主要用于pcs/pms.../fws
218.240.13.22 --> 10.192.1.60 root/file#9e04c9db7358
    主要用于lws/ldb/memcached/aws
    
密码分别为
    10.192.1.60 root/file#9e04c9db7358 
    10.192.2.4  root/com#b47da8611ff9 v2/v2E3736DE602D8







hclient管理工具问题：
svrctl --type=pm "admin_notify_actor --nick=nickname 'aaaa'"
hclient部署在 root@202.150.215.144/root/hipihi/run/hiclient 这里。
密码：yog2st$@@

我找到bug了
 使用banchat之后
 接下来的消息就都不能用了
 如果说banchat玩家A后，A收不到消息我能理解；但是如果banchat玩家A后，对B的消息也都不可以发送，我就不能理解了
 
svrctl --type=pm "admin_notify_actor --aid=300 'fsadASDSAD'"
svrctl --type=pm "admin_notify_actor --aid=300 'fsadfsadfsad'"
svrctl --type=pm "admin_notify_actor --aid=300 'fsadfsadfsad'"
svrctl --type=pm "admin_notify_actor --aid=200 'uat009!!'"

connect --bid=300 --host=202.150.215.155
jumpto --pid=100
log on

connect --bid=300 --host=202.150.215.155
svrctl --type=pm "admin_notify_actor --aid=100000000000000040 'aaaaaaaaaaaaaaaaaaaaaa'"

uat008 aid=21081481346547717 

connect --bid=300 --host=202.150.215.155

connect --bid=100 --host=202.150.215.155
jumpto --pid=5001,5001
svrctl --type=pm "admin_notify_actor --aid=300 'QQQQQQQQQQQQQQQQQQQQQQQQ'"
banchat --aid=300 --time=36000
svrctl --type=pm "admin_notify_actor --aid=300 'QQQQQQQQQQQQQQQQQQQQQQQQ'"
====>这个时候300用户收不到消息
svrctl --type=pm "admin_notify_actor --aid=200 'QQQQQQQQQQQQQQQQQQQQQQQQ'"
====>这个时候200用户还是可以收到消息



svrctl --type=pm "admin_notify_actor --aid=21081481346547717 'QQQQQQQQQQQQQQQQQQQQQQQQ'"
banchat --aid=21081481346547717 --time=180

http://10.192.0.44/logicwebserver/jsonservices/getCommunityMembers.do?communityid=93308908138922173
http://10.192.0.44/logicwebserver/jsonservices/getUserBuddies.do?userid=93274292128579587	
test IDC2, groupid= 4626981764457430621, niubi
test 4x,   groupid= 4683267431029859376 buniubi
test 4x,   groupid= 4683267431029859376, buniubi

login --id=100000000000000039 --host=10.192.0.43
sendgmsg --gid=4626981764457430621 "nnnnnnnnnnnnnnnnn"

login --id=100000000000000035 --host=202.150.215.155 --port=20000
sendgmsg --gid=4626981764457430621 "nnnnnnnnnnnnnnnnn" 
login --id=100000000000000039 --host=202.150.215.155 --port=20000
sendgmsg --gid=4626981764457430621 "nnnnnnnnnnnnnnnnn"

login --id=100000000000000039 --host=202.150.215.155 --port=20000


login --id=100000000000000035
sendgmsg --gid=4626981764457430621 "nnnnnnnnnnnnnnnnn"



NetWorkConfig.xml
<Admin all_func="true"  no_net="true"/>



两个问题：
1、curl安装路径问题
2、test的工程如何编译问题
3、${srcdir}/configure $2 $3 --prefix=${pkgdir} --includedir=${configrootdir}/include/$4  --libdir=${configrootdir}/lib;
   ${srcdir}/configure $2 $3 --prefix=${pkgdir} --includedir=${configrootdir}/include/  --libdir=${configrootdir}/lib;


g++ -g TestMain.cpp -llog4cxx -lcppunit -lhnetworklib -lcurl -lhoslib -I../include -I ../../hoslib/include/ -I /home/weizili/project/server/debug/include/cppunit-1.12.1/ -I /home/weizili/project/server/debug/include/ -I /home/weizili/project/server/debug/include/apr-1.3.3/ -I /home/weizili/project/server/debug/include/apr-util-1.3.4/ -L/home/weizili/project/server/debug/lib/



在Source Insight中使用WinAVR编译器GCC
http://blog.chinaunix.net/u/30708/showart_425378.html
	

CURLWork::CURLWork( const CURLService* pService )
{
	pService->addWork( this );	//编译错误
}





SVN上传错误：
Attempted to lock an already-locked dir

通过搜索，解决办法是 执行cleanup操作，就好了
记录在这，Subversion还要继续研究


VC2008编译错误：在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include "stdafx.h"”
工程属性 -》 c   项  -》 找到 “预编译”选项，选择关闭 

VS2008查找文件：在查找输入框中输入： >of HConnectServer

couchdb
http://wiki.apache.org/couchdb/HTTP_Document_API
http://10.192.0.40:5984/_utils/
http://wiki.apache.org/couchdb/Getting_started_with_C




文件服务器：
http://10.192.0.40/filewebserver/upload.html
http://10.192.0.40/filewebserver/download.html








修改一下设置，就可以解决C2471：
C\C++ | General | Debug Information format | C7 Compatible (/Z7)
C\C++ | Code Generation | Enable String Pooling | Yes (/GF)
Linker | General Debug Info | Yes (/DEBUG) 







vi
# *：读取光标处的字符串，并且移动光标到它再次出现的地方。
# #：和上面的类似，但是是往反方向寻找。
# ma：在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。
# `a：到书签 a 处。注意这个不是单引号，它一般位于大部分键盘的 1 的左边。
# `.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。

# /text：从当前光标处开始搜索字符串 text，并且到达 text 出现的地方。必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按 n。
# ？text：和上面类似，但是是反方向。


使用vim时按了CTRL+S键怎么办?
2007年07月31日 星期二 16:56
windows下的编辑器使用惯了, 今天使用vim, 无意中又按了一下CTRL+S, 结果vim像停掉了一样, 按什么键都不起作用了. 以前也碰到这种情况, 解决的办法是直接关了ssh客户端软件, 然后重新连接, 重新打开那个文件.

今天我直接在google上查了一下, 发现直接按CTRL+Q解决问题.

问题的原因: CTRL+S表示停止向终端停止输出; CTRL+Q恢复向终端输出流.
	
	
	
	
	
	

log4cxx windows compile 编译
http://yin-gang.spaces.live.com/blog/cns!756AF5FDCCD70454!449.entry
	
	
sed for windows
http://sourceforge.net/projects/gnuwin32/files/sed/sed-4.2-1-setup.exe/download




log4cxx windows编译

到apache页面（http://apr.apache.org/download.cgi）下载下列三个文件：
	apr-*-win32-src.zip
	apr-util-*-win32-src.zip
	apr-iconv-*-win32-src.zip
另外，下载apache-log4cxx-0.10.0.tar.gz

下载完成后将这三个文件分别解压缩到和上面源代码相同的目录下。然后按照如下步骤进行编译：

a. 将apr-*-win32-src.zip解压后的文件名修改为：apr
b. 将apr-util-*-win32-src.zip解压后的文件名修改为：apr-util
c. 将apr-iconv-*-win32-src.zip解压后的文件名修改为：apr-iconv
d. 将apache-log4cxx-0.10.0.tar.gz解压后的文件名修改为：log4cxx
现在目录结构看起来如下：
 D:\log4cpp.compile\
			|_	apr
			|_	apr-iconv
			|_	apr-util
			|_	log4cxx
			
e、打开D:\log4cpp.compile\apr\apr.dsw 编译
f、打开D:\log4cpp.compile\apr-iconv\apriconv.dsp 编译
g、通过vcVS2008的DOS工具进入DOS窗口，此处直接在运行命令栏中输入cmd也可，不过为安全起见最后从VS2008的工具栏进入DOS界面
h、进入 D:\log4cpp.compile\log4cxx ，执行configure.bat configure-aprutil.bat 两个批处理
	D:\log4cpp.compile\log4cxx>configure.bat
	D:\log4cpp.compile\log4cxx>configure-aprutil.bat
		
		注意：由于在configure-aprutil.bat文件中使用了linux下的sed命令，
		所以该步可能会出现类似找不到sed命令的错误，这是由于在windows环境下编译的缘故。
	去这个页面  http://sourceforge.net/projects/gnuwin32/files/sed/sed-4.2-1-setup.exe/download 下载 sed，
	先安装上sed后再执行 configure-aprutil.bat

i、打开D:\log4cpp.compile\log4cxx\projects\log4cxx.dsw 编译
	如果出现类似找不到 apr_icove*函数的问题，
	请在log4cxx的项目属性里添加下面的链接lib（包括括号） 链接器->输入->附加依赖项
"..\..\apr-iconv\libd\apriconv-1.lib"



2．实例代码

       a．打开.net2003，新建一个空白的win32控制台工程，假设工程名为Test

       b．添加一个cpp文件，文件名随便命名

       c．右键点击Test工程，选择”属性”，然后在C++选项卡中添加附加库目录，注意该目录为../ apache-log4cxx-0.10.0\src\main\include

       d．在属性的链接器输入选项卡的”附加依赖项”中添加” log4cxx.lib”       

       e．在cpp文件中输入如下测试代码：

    #include <log4cxx/logger.h>
    #include <log4cxx/PropertyConfigurator.h>

    using namespace std;
    using namespace log4cxx;

    int main(int argc, char* argv[])
    {
		string trace = "fa";
		string Property = "./log.properties";
		log4cxx::PropertyConfigurator::configure(Property);
		LoggerPtr logger = Logger::getLogger(trace);
		logger->info("info, How to use?");
		logger->debug("debug, How to use?");
		logger->warn("warn, How to use?");
		logger->error("error, How to use?");

        return 0;

    }

       f．新建一个文本文件，命名为log4cxx.properties，并键入如下内容：

    # 设置root logger为DEBUG级别，使用了ca和fa两个Appender

    log4j.rootLogger=DEBUG, ca, fa

     

    #对Appender fa进行设置：

    # 这是一个文件类型的Appender，

    # 其输出文件（File）为./output.log，

    # 输出方式（Append）为覆盖方式，

    # 输出格式（layout）为PatternLayout

    log4j.appender.fa=org.apache.log4j.FileAppender

    log4j.appender.fa.File=./output.log

    log4j.appender.fa.Append=false

    log4j.appender.fa.layout=org.apache.log4j.PatternLayout

    log4j.appender.fa.layout.ConversionPattern=%d [%t] %-5p %.16c - %m%n

     

    #对Appender ca进行设置

    # 这是一个控制台类型的Appender

    #  输出格式（layout）为PatternLayout

    log4j.appender.ca=org.apache.log4j.ConsoleAppender

    log4j.appender.ca.layout=org.apache.log4j.PatternLayout

    log4j.appender.ca.layout.ConversionPattern=%d [%t] %-5p %.16c - %m%n

       g． 将编译好的log4cxx.lib和log4cxx.dll及上面的log4cxx.properties文件拷贝之Test工程目录

      h．编译运行该文件，可以看到控制台输出相关日志，并且在工程目录下会得到一个output.log的日志文件



参考文档：
http://blog.csdn.net/houghstc/archive/2009/07/08/4332621.aspx
http://www.elpauer.org/?p=250
http://apr.apache.org/compiling_win32.html
	
	
	
	
	
	
	
	
	
只实现[]的可改变引用版本，     const引用版本不用实现了，理由是，因为异常处理的代码和手动用指针判断的代码量相当。	




















struct CS2PS_ACTOR_REQUEST_ENTER_PATCH_Resp
{
	OSLib::u8 nResult;
	Common::MoveState vMoveState;

	//! Load Serializer.
	friend OSLib::MemoryDataStream& operator >> ( OSLib::MemoryDataStream& file, CS2PS_ACTOR_REQUEST_ENTER_PATCH_Resp& val )
	{
		file >> ( OSLib::u8& )val.nResult
			 >> ( Common::MoveState& )val.vMoveState;
		return file;
	}

	//! Save Serializer.
	friend OSLib::MemoryDataStream& operator << ( OSLib::MemoryDataStream& file, const CS2PS_ACTOR_REQUEST_ENTER_PATCH_Resp& val )
	{
		file << ( const OSLib::u8& )val.nResult
			 << ( const Common::MoveState&)val.vMoveState;
		return file;
	}
};

有些序列化，都是的基本类型，可以考虑直接用memcpy，
为了方便序列化生成工具，可以增加新的标记以示直接用memcpy




Windows 程序错误检查
dev partener error detection


Linux 程序性能分析 gprof

[v2@i90 bin]$ gprof -b hconnectserver gmon.out > gprof.2010-07-16.09-57.txt




在不支持ssh key登录的站点也实现自动登录，就是用户不如输入密码
要解决问题

有些站点不提供sshkey登录，只让你用密码登录。因为ssh命令不让在命令行直接明文你给密码，所以每次登录要输入密码很不方便。
解决方法

受到这篇文章启发： http://linuxtoy.org/ar... ， 用sshpass可以解决。请阅读该文行。

更新我 .bash_alias 下面内容

以前是：
alias sshsrv01=’ssh 404@某服务器ip -p端口号’
这样输入 sshsrv01（就是ssh到sever01的简写 ：）,实际运行一个ssh登录命令，但需要输入密码才能登入。因为ssh命令不让你直接在命令行输入密码。

现在该行更新为：

  alias sshsrv01='sshpass -p 'ssh登录密码' ssh 404@某服务器ip -p端口号'

sshpass -p 可以让你在后面直接跟登录密码，密码要放在英文单引号中。

alias ssh44root="sshpass -p 'pass_44!hi' ssh root@10.192.0.44"

现在再次输入 sshsrv01， 直接就登录到server01上了，无须输入密码。和使用sshkey达到的效果一样。
注意

    * alias命令整体要放在英文单引号中。所以，命令中有2对单引号。**
    * 在登录时，sshpass让你觉得和用sshkey登录一样，但安全性上，passwd-based和key-based是不一样的。当然key-based安全！
    * 是否能运用到scp和rsync中我还没有试验。谁用了请说明。


sshpass 下载：http://sourceforge.net/projects/freshmeat_sshpass/files/
	
	


1.请问3D开发是不是必须先应该选择一条路：DirectX / OpenGL？用DX编程和用GL编程是不是有很大的区别？请问应该选哪个好呢？
2.请您推荐我学习的顺序（先掌握什么再掌握什么？一步一步来），请您推荐几本好书
3.3D编程是不是需要基础知识，就像什么“3D图形学原理”，这个东西难学吗？
4.学3D编程是不是需要掌握3DMax的应用？（对于我这个程序员来说）
5.这是某公司招聘3D程序员的要求，请问每条都有什么道理：
* 熟悉3D图形学原理
* 熟悉DirectX/OpenGL
* 熟悉3D几何,渲染管道优化
* 熟悉3DEngine架构设计者优先
* 熟悉汇编语言者优先
6.请对此感兴趣的朋友帮我顶啊:)

1 directx 和 opengl你可以把他们看成一个是VC++，一个是bc++
  他们实际上都可以看作是显示专用的一门语言，没有太多的差异
2 看书：计算机图形学，计算几何， 线性代数
3 必须，不难，高中生可以看明白大部分。入门容易，提高难，精通更难。
4 不必，3dmax是一个建模工具类似的还有rhino，maya，....
5 没有什么道理，从来都是先有职位后找人，从来不会因为你有什么技能而单独给你安排一个职位
  除非是一个不成熟的公司。
  从描述看，无非是要找一个三维引擎的程序员，汇编是为了优化效率
6 up


计算机图形学
3D游戏编程大师技巧
《Mathematics.for.3D.Game.Programming.and.Computer.Graphics》
The OpenGL Programming Guide - The Redbook

  《3D游戏编程大师技巧》是一本好书,宏篇巨著。所有的核心原理都掰得很碎。从理论证明到代码实现全部细致周详。而且有中文版。英文是《trick of 3d game programming gurus - advanced 3d graphics and resterization》。内容涵盖广泛。在900多页想把游戏编程，高级计算机图形学，光栅化原理和实现，线性代数与解析几何都讲清楚，野心非凡。当时邮电出版社要我翻译时，由于精力有限，这本书的厚度和广度让人望而却步。所以选了GPU GEMS来翻译。当时GPU的发展正在如火如荼，3D硬件从简单的光栅化处理器发展为可编程的专用处理器。但这本书则专门介绍3D的软件实现。和当时的趋势有些背道而驰。不过现在翻了下。感到在使用D3D GL API做硬件3D绘图之前，把光栅化所有原理和背后理论体系都搞清楚，将会使学习和开发进度成倍。涉及高级shader的技术也会进展迅速。     大学本科的计算机图形学是门初级入门课程。只能概要的建立一个知识框架。在应用技术方面，想在图形技术领域有所收获，要往里填补的理论知识很多。读过这本书，比较强的感受是如果从一开始建立比较牢固的理论体系，之后的技术研发速度会很快。实时三维图形学只是一个旁支。图形学理论知识体系对它非常重要。    想要更好的利用不断发展的GPU，对GPU工作原理，光栅化过程，背后的数学知识，都有深入了解的必要。这几年工作中，体会加深。    最近偶然翻到《数值分析》对常微分方程的数值解法，这是物理引擎的积分求解理论基础。大学都教授的这门课程忘差不多了。看siggraph创立 physics based modeling的paper时感到吃力。用GPU在shader里使用欧拉积分做布料也是一种很简化的数值计算方法。在书店找到几本计算几何学。是物理引擎碰撞部分的理论基础。另外物理引擎涉及到的一块是理论力学的刚体动力学部分。具体计算还要使用LCP（线性互补问题）的解法。涉及到软体的物理模拟情况就更复杂一些。感觉短时间是不太容易都找补全。用一用商业的AGEIA物理引擎可能只需要高中的数学勉强就够了。不过真要做一套，没有一些数学底子还是很困难的一件事。传闻盛大的疯狂赛车根本没用物理。当然，当初的玛利奥赛车也不用。所以说游戏制作是个很玄妙的事。。。和技术似有关似无关。。。。。。  《3D游戏编程大师技巧》的作者是个非常专业的技术人员。并且在介绍技术时，对重要的原理和公式都有推导和论证的过程。这样的作法在技术应用书籍里其实很少。多数初等技术书籍都在讲述一个API有几个参数每个参数什么意思。这本书实际在用CPU实现一个简化GPU。作者一看就是对3D RENDERING和游戏编程每个细节都有大量实践。所以从理论知识到技术实现细节，包括优化，讲解很通透。做为大学游戏专业的教材是最适合不过。

         在查阅书中用到的数学公式时，发现另外一个堪比《REALTIME RENDERING》的经典书籍：《Mathematics.for.3D.Game.Programming.and.Computer.Graphics》。这本书比《3D ENGINE DESIGN》要平易近人得多。本着实用的角度，用浅显易懂的描述语言对游戏和计算机图形学用到的数学知识一一进行讲解和证明。比起另外一本经典著作《3D ENGINE DESIGN》，其作者是个博士，全书都用教科书般精确简练的数学语言描述3D引擎理论体系，对没有受过专门数学训练的人读起来都是颇为吃力。《MATH FOR 3D GAME AND CG》则是从实际工程技术角度出发，用高中数学课本形式的语言详细介绍了3D图形编程中所用到的数学知识，同时还保持了广度和深度。同样类型的书籍还有《PHYSICS BASED RENDERING》和《PHYSICS BASED ANIMATION》。当然知识体系更深入。

      看全局光照时，PRT着实让数学不好的人头大。手头必须常备微积分，微分方程，概率学，傅里叶变换等一些书籍。残缺不全的知识体系很挠头。这是任凭多少技术实践也无法倒推补全的。中间发现一套非常好的微积分教程。俄国菲赫金哥尔茨的《微积分学教程》全3卷。我感觉大学要是用这个当教材我现在的日子还能过得稍微舒服一点点。
      
      http://www.realtimerendering.com
      	http://www.opengl.org/
      		
      		



vs2008




线程局部存储
 VC 
     __declspec( thread ) 
 G++ 
     __thread







客户端开发：
HWorld.h 窗口类的管理器
HWorld.cpp 按键消息也在这里处理：bool CHipihiWorld::keyClicked(KeyEvent& ke)
显示文字需要设置：textrender，


HipihiClient::IClientPatchAssembly* ScriptManager::refPatchAssembly( const Common::ResRef& resRef )


射箭游戏地点：f4 120 76 766
f6进入物品编辑，关闭脚本。  f3返回正常无脚本状态











莫名其妙的错误查找方法（VS2008）：
报错文件属性->C/C++ ->预处理器->生成预处理文件-> 带行号(/p)，右键单独这个文件。
这样在该文件的同级目录会生成一个相同文件名的后缀为 *.i 的文件。
然后按照报错的地方查找。








这个共你参考表结构
http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/database-guide.html
zhangliang(张亮 - 沙僧) 18:36:46
http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/javadoc/org/jivesoftware/openfire/roster/RosterManager.html
zhangliang(张亮 - 沙僧) 18:37:08
http://xmpp.org/extensions/xep-0144.html
供参考
zhangliang(张亮 - 沙僧) 18:37:17
http://xmpp.org/
weizili(魏自立 - 雷震子) 18:38:51
好的。我保存了。呵呵
zhangliang(张亮 - 沙僧) 18:39:01
仅供参考
zhangliang(张亮 - 沙僧) 18:39:30
咱们可以看看别人怎么弄，尽量能想一些标准靠，个人建议，呵呵
zhangliang(张亮 - 沙僧) 18:40:28
重复造轮子成本太高
weizili(魏自立 - 雷震子) 18:40:52
恩。好建议




田生彩 说 (10:48):
户口怎么样了，老板提了没
现在是户口指标最多的时候了，提醒魔王
魏自立 说 (10:49):
提了，还是在等消息
田生彩 说 (10:50):
一个指标最贵5万(二手市场)，一手市场(2-3万), 关系户4000，应该不难的。 催魔王，让他多提。老板得要多几条通道，不能只靠一家公司啊



DOS命令
set FileName=ChatClientLibTest-%date:~0,4%.%date:~5,2%.%date:~8,2%-%time:~0,2%.%time:~3,2%.%time:~6,2%
set ToolDirName=deploy\%FileName%
set HipihiClientDir=..\..\..\..\client\trunk\HipihiVirtualWorld\bin\debug

mkdir %ToolDirName%
mkdir %ToolDirName%\bin
mkdir %ToolDirName%\etc

copy *.dll 							%ToolDirName%\bin
copy *.lib 							%ToolDirName%\bin
copy HChatClientLibTest.exe 		%ToolDirName%\bin
copy HMsg*.exe 						%ToolDirName%\bin
copy runmsgservice.bat				%ToolDirName%\bin
copy ..\etc\* 						%ToolDirName%\etc
copy ..\..\src\hmsgservicelib\doc\Test.Case.And.Usage.doc %ToolDirName%


copy %HipihiClientDir%\ms*.dll 		%ToolDirName%\bin
copy %HipihiClientDir%\*.manifest 	%ToolDirName%\bin

rar.exe -a %ToolDirName%\..\%FileName%.zip %ToolDirName%
pause


"%date:~0,10% "              从当前系统日期中第"0"位开始取出"10"位
"%time:~0,2% "              从当前系统时间中第"0"位开始取出"2"位 







重启
[root@hi43 rc3.d]# shutdown -r now


linux 自启动
下面用自启动apache为例;
自启动脚本:
/usr/local/apache2/bin；
./apachectl start
文件位于/etc/rc.d/init.d下,名为apached, 注意要可执行.
#chmod +x /etc/rc.d/init.d/apached //设置文件的属性为可执行
#ln -s /etc/rc.d/init.d/apached /etc/rc3.d/S90apache //建立软连接,快捷方式
#ln -s /etc/rc.d/init.d/apached /etc/rc0.d/K20apache

建立步骤
1、建立 /etc/init.d/v2servers 内容：
#
# chkconfig: - 91 35
# description: Starts v2 connectserver patchserver patchmarshalserver
BIN_DIR=/home/leizhenzi/workspace/v2/server/trunk/cdt/bin/Debug
su - leizhenzi
cd $BIN_DIR
. setlibpath.sh
. ./runservers.sh
#logout

2、然后去 建立一个软连接
ln -s /etc/init.d/v2servers /etc/rc3.d/K20v2server


chkconfig add




Understanding Red Hat Run Levels  http://www.linuxjournal.com/article/1274

If you're one of those who took a chance and got one of the Caldera Previews or got a Red Hat distribution on your system, one of your original thoughts may have been the same as mine: What happened to /etc/rc.local? Where am I supposed to put my custom commands? [One answer: /etc/rc.d/rc.local is available on Red Hat systems―ED] What if I don't want the HTTP server to start?

For those of you out there who administer Sun Solaris machines, this looks quite familiar. But I was just scratching my head for a while until I wound up administering a system, and it all became clear. Time to share the knowledge.

The idea behind the setup is to make everything script-based. For each run level, scripts are run to start each individual service, instead of having a few large files to edit by hand. These scripts are located in /etc/rc.d/init.d, and most take as an option start or stop. This is to allow the specific programs to start (on bootup) or stop (on shutdown).

This setup involves a bunch of directories under /etc/rc.d/. These are:

rc0.d Contains scripts to run when the system shuts down. Technically, halt or shutdown bring the system to runlevel 0. This directory is mostly made up of kill commands.

rc1.d through rc3.d Scripts to run when the system changes runlevels. Runlevel 1 is usually single-user mode, runlevel 2 is for multi-user setup without NFS, and runlevel 3 is full multi-user and networking.

Runlevel 4 is typically unused.

rc5.d Scripts to start the system in X11 mode. This is the same as runlevel 3, with the exception that the xdm program starts, which provides a graphical login screen.

rc6.d Scripts to run when the system reboots. These scripts are called by a reboot command.

init.d Actually contains all of the scripts. The files in the rc?.d directories are really links to the scripts in the init.d directory.

The Boot Sequence
Now that we know where files are located, let's look at what happens in a normal Red Hat boot sequence.

Once the system boots, /etc/rc.d/rc.sysinit is run first. The starting runlevel (specified in /etc/inittab) is found, and the /etc/rc.d/rc script is run, with the sole option being the runlevel we want to go to. For most startups, this is runlevel 3.

The rc program looks in the /etc/rc.d/rc3.d directory, executing any K* scripts (of which there are none in the rc3.d directory) with an option of stop. Then, all the S* scripts are started with an option of start. Scripts are started in numerical order―thus, the S10network script is started before the S85httpd script. This allows you to choose exactly when your script starts without having to edit files. The same is true of the K* scripts.

Let's look at what happens when we switch runlevels―say from runlevel 3 (full networking and multi-user mode) to runlevel 1 (single-user mode).

First, all the K* scripts in the level to which the system is changing are executed. My Caldera Preview II (Red Hat 2.0) setup has seven K scripts and one S script in the /etc/rc.d/rc.1/ directory. The K scripts shut down nfs, sendmail, lpd, inet, cron, and syslog. The S script then kills off any remaining programs and executes init -t1 S, which tells the system to really go into single-user mode.

Once in single-user mode, you can switch back to full multi-user mode by typing init 3.

Side-stepping init
There are two additional points I can make here.

First, you can selectively start and stop scripts, even those not native to your runlevel. Executing scripts in /etc/rc.d/init.d/ with an option of start or stop will start up or stop the programs or services which the script controls. This allows you to turn off NFS from runlevel 3 while keeping all other systems active, for example. Similarly, you can start NFS back up when you are ready.

Stopping NFS in this case would require stopping two systems―nfsfs and nfs. The nfsfs script will mount or ummount any of the NFS-mounted file-systems listed in your /etc/fstab. The nfs script would then shut down the processes associated with NFS, in this case mountd and nfsd.

So the proper procedure for shutting down NFS would be:

# /etc/rc.d/init.d/nfsfs stop
Unmounting remote filesystems.
# /etc/rc.d/init.d/nfs stop
Shutting down NFS services: rpc.mountd rpc.nfsd
#
And starting NFS would be:

# /etc/rc.d/init.d/nfs start
Starting NFS services: rpc.mountd rpc.nfsd
# /etc/rc.d/init.d/nfsfs start
Mounting remote filesystems.
#





如果早晨你们在8：30后（或者早到公司）发现10.192.0.42、10.192.0.43没有开机

请SSH登录10.192.0.8（总是开机状态）
username: root
password: svn#hipiHi

shell下执行下面两句命令

#启动10.192.0.42
ipmitool -I lan -H 10.192.0.52 -U root -P 123456  power on 

#启动10.192.0.43
ipmitool -I lan -H 10.192.0.53 -U root -P 123456  power on 
















A)
如果
	1) 使用msvcrt8以上，那么__CRTDLL_INIT会执行_check_manifest()
	2) XP以上系统存在SxS服务(通过policy指向最新dll)
				<XP			>=XP
---------------------------------------
<msvcrt8		/			/
>=msvcrt8		?			check()

B) vc8以上，/MD情况下
	1) vs默认test.exe.intermediate.manifest 并且 隐式 mt合并入程序
		1.1) 用mt查看一下？
			mt -inputresource:test.exe;#1 -out:xxx.manifest
	2) /MANIFEST:NO 不能找到msvcrt
		2.1) mt 补救
			采用1.1)导出的xxx.manifest或者3)产生的manifest文件,合并入 test.exe
			mt -outputresourc
taosheng(陶盛 - 二郎神) 10:26:45
e:test.exe;#2 -manifest test.exe.manifest
	3) /MANIFEST 产生 显式 test.exe.manifest,又可以找到相应SxS服务
taosheng(陶盛 - 二郎神) 10:27:08
manifest总结如上，如果有问题，最简单的方法是用mt修补一下
zhouhe(周赫 - 葫芦娃) 10:29:03
 
taosheng(陶盛 - 二郎神) 10:30:20
emb是用cygwin make编译的，许多选项修改会比较麻烦，所以用mt.exe修复一下最为简单，如果自己写的工程，就很容易控制manifest选项了









第一种方法：
ls -l|grep “^-”|wc -l
ls -l 长列表输出该目录下文件信息(注意这里的文件，不同于一般的文件，可能是目录、链接、设备文件等)。如果ls -lR|grep “^-”|wc-l则可以连子目录下的文件一起统计。
grep ^- 这里将长列表输出信息过滤一部分，只保留一般文件，如果只保留目录就是 ^d
wc -l 统计输出信息的行数，因为已经过滤得只剩一般文件了，所以统计结果就是一般文件信息的行数，又由于一行信息对应一个文件，所以也就是文件的个数。
第二种方法：
find ./ -type f|wc -l
由于默认find会去子目录查找，如果只想查找当前目录的文件用find ./ -maxdepth 1 -type f|wc -l即可。
需要说明的是第二种方法会比第一种方法快很多，尤其是也统计子目录时。








linux cdt
${env_var:LD_LIBRARY_PATH};${workspace_loc:/hconnectserver}/../lib/Debug






2010-06-22 14:57:04,830  INFO (?:-1) RealActor  - An actor login successfully, id=49612756224265114
2010-06-22 14:57:09,845  INFO (?:-1) cs_RealActor  - An actor connected.
2010-06-22 14:57:09,939  INFO (?:-1) cs_RealActor  - An actor connected.
2010-06-22 14:57:10,626  INFO (?:-1) cs  - An actor destroyed. ID=0
2010-06-22 14:57:11,029  INFO (?:-1) CSActorManager  - Found duplicated actor in CSActorManager::addNamedActor, actor id=49612756224265114
2010-06-22 14:57:11,029  INFO (?:-1) cs  - An actor destroyed. ID=49612756224265114
2010-06-22 14:57:11,030  INFO (?:-1) RealActor  - An actor login successfully, id=49612756224265114
2010-06-22 14:57:16,026  INFO (?:-1) cs_RealActor  - An actor connected.
2010-06-22 14:57:17,105  INFO (?:-1) CSActorManager  - Found duplicated actor in CSActorManager::addNamedActor, actor id=49612756224265114
2010-06-22 14:57:17,105  INFO (?:-1) cs  - An actor destroyed. ID=49612756224265114
2010-06-22 14:57:17,105  INFO (?:-1) RealActor  - An actor login successfully, id=49612756224265114
2010-06-22 14:57:22,100  INFO (?:-1) cs_RealActor  - An actor connected.
2010-06-22 14:57:23,181  INFO (?:-1) CSActorManager  - Found duplicated actor in CSActorManager::addNamedActor, actor id=49612756224265114
2010-06-22 14:57:23,181  INFO (?:-1) RealActor  - An actor login successfully, id=49612756224265114
2010-06-22 14:57:23,367  INFO (?:-1) cs  - An actor destroyed. ID=49612756224265114
2010-06-22 14:57:23,367 ERROR (?:-1) assert  - !m_pPatch
file name:../src/HCSActor.cpp
line26
hconnectserver: ../src/HCSActor.cpp:26: Assertion '!m_pPatch' failed.
Aborted













shell脚本执行之后提示错误
line 17: syntax error: unexpected end of file

我在网上搜到这种错误都是没有结束标记造得的
如if之后没有fi
for 循环 do之后没有done
while 循环 do这后没有done
可是这段脚本少了什么啊













How to create and apply a patch with Subversion
July 3rd 2007

It’s been a while since I posted something new on the use of Subversion. I’ve been working with the tool a lot, and I’ve found that patches are a great way to communicate code changes.

For those of you who are still learning, let me first explain what a patch is. A patch is a text file that contains the alteration that were made to a specific file. It includes the lines that have been removed and the lines that have been added. In short, if you have a ruby script and edited it, you could create a patch file, containing the changes you’ve made.

Why is this useful? You could check in your changes to your repository directly. True, but there are cases that you don’t have write access to the repository. For example, if you wanted to contribute code changes to Acts As Exportable, you should create a new ticket and attach a patch file. I will then review your changes before I apply them to the code and commit them to the repository.

So, how do you go about creating a patch file and how do you later apply it to your source?
Creating a patch file

Creating a patch file is really easy. First, check out the most recent version of the code from Subversion using the ‘checkout’ command.

Make your changes.

Then, in the root the project run the following command. It will store the patch file in your home directory. Make sure to give it meaningful filename.

svn diff > ~/fix_ugly_bug.diff

The file has the .diff extention, which stands for differences. This extension is recognized by many text editors and enables ‘syntax highlighting’ automatically. (Give it a try with TextMate and you’ll know what I mean.)

You can send the diff-file to the author of the project by email, or you can create a ticket in Trac and add it as an attachment. The author will review the changes you made and possibly apply them to the source.
Applying a patch

You should never apply patches from any person other than your development team without first reading through the changes, apply them locally and test your application and then commit them. Patches can not only include bug fixes, but also alterations to create back doors or add other exploits to your code.

Always read through a patch before applying it!

When you are sure the patch will bring no harm to you, your application or your customers, go ahead an apply it to your working copy. Here, I assume that you downloaded the patch file we previously generated, and placed it in your home directory. In the root of your application now run:

patch -p0 -i ~/fix_ugly_bug.diff

This will apply all the changes in the patch to your source. The -p0 option makes sure that all files can be found correctly (this has to do with something called ‘zero directories’, I won’t get into that right now). The -i option tells ‘patch’ what to use as input, in this case the ‘fix_ugly_bug.diff’ file in your home directory.

With the code changes in place, run your tests and make sure everything works as expected. If it does, commit your changes and celebrate with a cup of coffee.




svn merge
Prev 	svn Subcommands	 Next
Name

svn merge ― Apply the differences between two sources to a working copy path.
Synopsis

svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]

svn merge -r N:M SOURCE [PATH]

Description

In the first form, the source URLs are specified at revisions N and M. These are the two sources to be compared. The revisions default to HEAD if omitted.

In the second form, SOURCE can be a URL or working copy item, in which case the corresponding URL is used. This URL, at revisions N and M, defines the two sources to be compared.

WCPATH is the working copy path that will receive the changes. If WCPATH is omitted, a default value of “.” is assumed, unless the sources have identical basenames that match a file within “.”: in which case, the differences will be applied to that file.

Unlike svn diff, the merge command takes the ancestry of a file into consideration when performing a merge operation. This is very important when you're merging changes from one branch into another and you've renamed a file on one branch but not the other.
Alternate Names

None
Changes

Working copy
Accesses Repository

Only if working with URLs
Switches

--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--force
--dry-run
--diff3-cmd CMD
--ignore-ancestry
--username USER
--password PASS
--no-auth-cache
--non-interactive
--config-dir DIR

Examples

Merge a branch back into the trunk (assuming that you have a working copy of the trunk, and that the branch was created in revision 250):

$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch
U  myproj/tiny.txt
U  myproj/thhgttg.txt
U  myproj/win.txt
U  myproj/flo.txt

If you branched at revision 23, and you want to merge changes on trunk into your branch, you could do this from inside the working copy of your branch:

$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors
U  myproj/thhgttg.txt
…

To merge changes to a single file:

$ cd myproj
$ svn merge -r 30:31 thhgttg.txt 
U  thhgttg.txt







http parse

You can retrieve the name/value pairs by searching for newline newline or more specifically \r\n\r\n (after this, the body of the message will start).

Then you can simply split the list by the &, and then split each of those returned strings between the = for name/value pairs. 






POD type
plain   old   data，可以那么理解，就是以前的c语言里面的类型和struct，或者class定义里面单单只是数据，不涉及其他的指针操作，也就是说可以通过memcpy拷贝旧可以完成复制的



C++ Language Note:
POD Types
Walter E. Brown
September 29, 1999; last updated November 29, 1999
1.  Purpose
This note documents the definition of a POD type according to the International Standard for the C++ Programming Language [ISO/IEC 14882, first edition, 1998-09-01].  Related definitions are also provided, as is interpretive commentary on the significance of a POD-type.  All references herein are to the Standard.
2.  Definitions
The term POD is an acronym.  It stands for "plain old data" [p. 5, footnote 4], and is intended to suggest areas of substantive compatibility between comparable data types in C and C++.  The terms POD and POD object are often used interchangeably to refer to an object of POD type.

The term POD types collectively refers to the following categories of C++ types, and encompasses both cv-qualified versions of these as well as arrays of these [§3.9, ?10; §9, ?4]:

    * scalar types, and
    * POD class types.

The term scalar types collectively refers to the following categories of C++ types, and encompasses cv-qualified versions of these [§3.9, ?10]:

    * arithmetic types,
    * enumeration types,
    * pointer types, and
    * pointer-to-member types.

The term arithmetic types collectively refers to the following categories of C++ types [§3.9.1, ?8]:

    * integral (also known as integer) types, and
    * floating (also known as floating point) types.

The term integral types collectively refers to the following C++ types [§3.9.1, ?7]:

    * signed integer types (signed char, short, int, long),
    * unsigned integer types (unsigned char, unsigned short, unsigned int, unsigned long),
    * char and wchar_t, and
    * bool.

The term floating types collectively refers to the C++ types float, double, and long double [§3.9.1, ?8].

The term enumeration types collectively refers to distinct types, known as enumerations, that comprise sets of named constant values [§3.9.1, ?1; §7.2, ?1].

The term pointer types collectively refers to the following categories of C++ types [§3.9.2, ?1]:

    * pointer-to-void (void *),
    * pointer-to-object and pointer-to-static-member-data (both of the form T* when pointing to an object of type T), and
    * pointer-to-function and pointer-to-static-member-function (both of the form T (*)(...) when pointing to a function that returns an object of type T).

The term pointer-to-member types collectively refers to the following C++ types [§3.9.2, ?1]:

    * pointer-to-nonstatic-member-data (of the form T C::* when pointing to one of class C's data members that has type T), and
    * pointer-to-nonstatic-member-functions (of the form T (C::*)(...) when pointing to one of class C's member functions that returns an object of type T).

The term POD class types collectively refers to aggregate classes (POD-struct types) and aggregate unions (POD-union types) that have none of the following as members [§9, ?4]:

    * non-static data (including arrays) of any pointer-to-member type,
    * non-static data (including arrays) of any non-POD class type,
    * non-static data of any reference type,
    * user-defined copy assignment operator, nor
    * user-defined destructor.

The term aggregate refers to an array or class that has none of the following characteristics [§8.5.1, ?1]:

  # user-declared constructors,
  # private or protected non-static data members,
  # base classes, nor
  # virtual functions.

3.  Commentary
POD types have primary significance as an important source of compatibility with ANSI C code.  As such, objects of these types share several characteristics with their C equivalents.  These characteristics include initialization, copying, layout, and addressing.

As an example of the sometimes-subtle distinction between POD and non-POD types, consider the initializations implied by each of the following new-expressions [§5.3.4, ?15]:
 
expression 	POD type T 			non-POD type T
 new T 		not initialized 	default-initialized
 new T() 	always 				default-initialized
 new T(x) 	always 				initialized via a constructor

Thus, an object (or an array) of non-POD type is always guaranteed initialization, while an instance (or an array) of a POD type may be left uninitialized.

Other POD-related C++ characteristics include the following:

   1. Layout
          * The bytes constituting a POD object are contiguous [§1.8, ?5].
          * "POD-struct ... types are layout-compatible if they have the same number of members, and corresponding members (in order) have layout-compatible types" [§9.2, ?14].
          * POD-union ... types are layout-compatible if they have the same number of members, and corresponding members (in any order) have layout-compatible types" [§9.2, ?15].
   2. Initialization
          * A non-const POD object declared with no initializer has an "indeterminate initial value" [§8.5, ?9].
          * Default initialization of a POD object is zero initialization [§8.5, ?5].
          * A static POD object declared with an initializer is given its initial value:
                o if local, "before its block is first entered" [§6.7, ?4]; else
                o if non-local, "before any dynamic initialization takes place" [§3.6.2, ?1].
   3. Copying
          * The bytes constituting a POD object can be copied (e.g., via memcpy())
                o to a sufficiently large array of char or unsigned char and back again without changing the object's value [§3.9, ?2], or
                o to another object of the same POD-type, in which case the second object's value will be the same as that of the first [§3.9, ?3].
          * Any POD type may be used as the "character" type in the standard's templated string classes [§21, ?1].
   4. Addressing
          * The address of a POD object can be an address constant expression (or part of one) [§5.19, ?4], while a reference to a POD member can be a reference constant expression [§5.19, ?5].
          * "A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member ... and vice versa" [§9.2, ?17]."






















多人游戏位置同步――带宽限制下的视觉实体属性传播

时间同步

在多台机器之间维护时间需要一种同步机制。通常的同步方案是，在本地机器时间与服务器时间之间计算一个差值和参考时间，然后传输与参考时间之间的时间戳。但是，我们注意到一些机器的内部时钟速度不一样，这样会导致错误的同步。
此外，我们的服务器应用程序采用了一种灵活的时间系统，该系统基于一个可发送”ticks”的指挥服务，这样可以以所有的服务器应用程序都接受的比率增加当前游戏循环的速度：如果一个服务突然增加了工作负载，所有的服务都可以停下来等它，以避免恶意循环的阻塞。客户端时间同步因此基于收到的两个消息包的平均时间，假设服务器定期地发送数据包到所有的客户端。

4、更新频率控制 C 优先级策略

虽然大家都认为消费者的调制解调器和带宽在未来几年内会增加很多，但是保持一个低的传输率仍然具有降低带宽使用费用的优势。毕竟，运行一台支持数以千计的玩家同时游戏的服务器(这也是MMOG的本质)仍然需要很大的网络连接，而这也不可避免地是相当的昂贵。
在一个比较热闹的3D场景中以13kb/s的速度(一般设置的瓶颈值)传输位置更新包也给我们带来了以下问题：哪些更新包具有高的优先级 ？需要的CPU效率是多少 ？
我们也尝试了多种算法，他们的基本原理也都是相同的。对一个特定的观察者来说，在一个给定的时间：
在无缝的世界环境中决定哪些实体在观察者的周围，并且发送这个列表的更新到客户端。 根据距离来为列表中的这些实体指定优先级。 根据优先级高低顺序遍历这些实体, 比较他们当前的服务器端状态与客户端保留状态的差别，添加更新数据包到缓冲区，到缓冲区大小达到带宽瓶颈时停止。

计算可见实体

Ryzom中使用了两种主要的算法。
第一种被用于Ryzom的大陆。空间被一个网格所划分，首先获取与要计算的实体在同一网格的实体，然后以螺旋状的方式遍历周围的网格，并添加其中的实体，直接找到足够数量的实体。
对于Ryzom Ring副本来说，区域一般都比较小，所以采用了一种新的算法：根据实体当前位置与组重心的距离来创建动态组。如果实体移动到离组很远的地方，就将组一分为二：创建一个新组出来。
这两种情况的结果都是相同的：每个客户端游戏实体都与一个其可见的实体集合相关联。解释这些算法的细节已经超出了本篇文章的范畴，但接下来我们将看到这些关联和他们的属性是如何以及何时发送给客户端的。

优先级：信息的相关性

我们曾经尝试过的一种算法是通过以下方法构造的：试图将一个属性的更新频率与该属性更新所引起的观察者屏幕上受影响的象素数量相关联。实际上，第一个基于预算的算法被开发用来处理每个属性：每个元组(观察者客户端，观察的实体，属性)被赋予一个优先级，还有一个数据结构用于表示”架子和桶”，这些在发送更新包到客户端时会被浏览到。优先级帮助将一个属性的改变事件映射到一个正确的桶上。它是通过一些标准计算出来的：
从观察者到实体的距离
客户端所知道的状态拷贝与其实际数据之间的差值
对于位置来说，我们解决了当实体移动了一段很长的距离而实际差值却非常小时可能会引起的问题：比如，当在墙上行走时，开始点和结束点可能会非常接近，而在这种情况下的改变又是很重要的。我们通过比较”移动的数量”来代替移动的位置，这样我们也就不得不在每次检测到实体移动之后都进行累积。
其他属性也同样被列入考虑。比如，如果一个被观察实体突然戴上了他的帽子，而并没有移动，这个实体也同样会获得一个比较高的更新优先级。
这个算法在我们25*250*1000个元组(每个前端服务有1000个客户端，每个客户端显示250个实体，每个实体有25个动态属性)的目标上被证明是太过于耗费CPU资源的。因此，另外一个不同的算法又被开发出来，通过下面的标准为每个元组(观察者，被观察的实体)计算分值：

观察者到实体的距离

实体分值的增长与它到观察者的距离成反比，当状态更新包被发送到观察者的客户端后，分值被重置。另外一个步骤用来对特定的被观察的实体进行处理，以决定哪些属性需要发送给观察者。

决定哪些属性需要被发送

当根据优先级遍历被观察的实体时，我们会将实体当前的属性与保存下来的上一次发送更新时的属性值进行比较，发送改变过的部分。如果他们不匹配，我们会在有足够的资源时将他们包含进更新数据包中并且发送。上一节中描述过的路程跟踪被保留用来做位置仲裁。这个比较也是一个非常关键的部分，因为其被调用的次数非常多，我们也使用了相当多的手段来对其进行优化。我们随后通过仅比较那些与实体类型有关的属性来对整个步骤进行了优化。比如，我们提前已经知道在 Ryzom中智能植物是一种位置固定的实体，这样我们就不需要比较它的位置属性是否已改变了。
优化
为了减少一个游戏循环中所做的操作的次数，我们添加了一个用来将游戏循环分隔为多个游戏循环的系统。这样，一次只会有一部分的可见实体做优先级计算。
另一项优化策略在于使用多处理器的优势：计算部分和发送部分被安排在不同的线程中。
低级的优化处理也做过：通过显示c++编译器生成的汇编代码，我们重新设计了数据结构，以使得处理器在获取这些数据的时候尽可能地减少缓存未命中的情况。














windows visual studio main 函数链接错误
1>------ 已启动生成: 项目: Freakout, 配置: Debug Win32 ------
1>正在链接...
1>MSVCRTD.lib(crtexe.obj) : error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStartup 中被引用
1>E:\3dstudyprojects\Freakout\Freakout1\Debug\Freakout.exe : fatal error LNK1120: 1 个无法解析的外部命令
1>生成日志保存在“file://e:\3dstudyprojects\Freakout\Freakout\Freakout\Debug\BuildLog.htm”
1>Freakout - 2 个错误，0 个警告

修改-> 工程属性->链接器->系统->子系统->Windows (/SUBSYSTEM:WINDOWS)
	
	
	
	




test_memalloc --type=1 --memsize=1024 --everycount=10 --totalcount=10 --premalloccount=1024 --usemempool=true

说一下OSLib::MemAlloc测试情况。
	
测试的用例是这样的，在同一个线程中，首先分配premalloccount个大小为随机值的内存，然后
每次分配一次内存，就立即释放这个内存，重复everycount次。
测试的内存大小是从1个字节到memsize个字节，每个数字都测试到。
测试总次数为totalcount次。

看下面的程序就很快明白：

for ( u32 i = 0; i < totalcount; ++i )
{
    for ( u32 size = 1; size <= memsize; ++size )
    {
        for ( u32 count = 0; count < everymalloccount; ++count )
        {
            if ( bUseMemPool )
            {
                void* p = OSLib::MemAlloc::alloc( size );
                OSLib::MemAlloc::free( p );
            }
            else
            {                    
                void* p = malloc( size );
                free( p );
            }
        }
    }
}//end of for

说明，每次测试一个完成后，程序会重启，以避免相互影响。
下面是测试用例release：

test_memalloc --type=1 --memsize=1048576 --everycount=1 --totalcount=1
using OSLib::MemAlloc, time=0.082545s, 82.545ms, 82545us
using system malloc, time=1.63257s, 1632.57ms, 1632569us

	
test_memalloc --type=1 --memsize=1048576 --everycount=10 --totalcount=10
14:51:23: warning : using OSLib::MemAlloc, time=8.28866s, 8288.66ms, 8288659us 
14:55:19: warning : using system malloc, time=161.6s, 161600ms, 161599711us 	
	
从上面几个简单的测试用例，可以看到 OSLib::MemAlloc 比系统直接分配快了不止20倍,,  **20**倍。。。
当然，测试用例有些片面，但足以说明问题。



test_memalloc --type=1 --memsize=1024 --everycount=10 --totalcount=10 --premalloccount=1024 --usemempool=true
using OSLib::MemAlloc, time=0.012991s, 12.991ms, 12991us

test_memalloc --type=1 --memsize=1024 --everycount=10000 --totalcount=10000 --premalloccount=2048 --usemempool=true























1秒钟刷新一次时间
[v2@i90 bin]$ watch -n 1 date
Every 1.0s: date                                                 Fri Jul 16 09:53:09 2010
Fri Jul 16 09:53:09 CST 2010









http://stackoverflow.com/questions/197444/building-libcurl-with-ssl-support-on-windows
	
Well, since this post failed badly, I had to dig into the matter myself.

So here goes:
Preprocessor

The following two symbols need to be fed to the preprocessor to enable SSL for libcurl:

USE_SSLEAY
USE_OPENSSL

(libcurl uses OpenSSL for SSL support)

Alternatively the symbols can be added directly to a file called setup.h in libcurl, but I'm not too happy about modifying code in 3rd party distributions unless I really have to.

Rebuilding the libcurl library, I now got some errors about OpenSSL include files not being found. Naturally, since I haven't set up the OpenSSL distribution properly yet.
Compiling OpenSSL binaries

I downloaded the OpenSSL 0.9.8 source distribution and unpacked it.

In the root of the source distribution there's a file called INSTALL.W32 which describes how to compile the OpenSSL binaries. The build chain requires perl, so I installed the latest version of ActivePerl.

I had some trouble with the build, which might not be applicable to all systems, but I'll go through it here in case somebody experiences the same.

According to INSTALL.W32:

Run the following commandline tasks with current directory set to the source distribution root:

1> perl Configure VC-WIN32 --prefix=c:/some/openssl/dir

(Where "c:/some/openssl/dir" should be replaced by the dir where OpenSSL should be installed. Don't use spaces in this path. The compilation further ahead will fail in that case)

2> ms\do_ms

(For me this step was unsuccessful at first, since I lacked the environment variables OSVERSION and TARGETCPU. I set these to 5.1.2600 and x86 respectively. You may get complaint about OSVERSION being "insane", but look closer, this error is for WinCE and doesn't affect the Win32 setup.)

3> nmake -f ms\nt.mak (for static library)

or

3> nmake -f ms\ntdll.mak (for DLL)

The source now compiles. Took approx 5 minutes on my laptop.

When compilation is completed, the libs or binaries have been placed in:

distroot/out32 - for static library build

or

distroot/out32dll - for DLL build
Building and linking

Now, back to visual studio and point out the libs and include path for headers. The include files are located in distroot/inc32/openssl.

Rebuild the libcurl project.

Error!

Well at least for me with this version of OpenSSL. it complained about a struct typedef in one of the OpenSSL headers. I couldn't find any info on this. After an hour of googling I broke my own principle and commented out the typedef from the OpenSSL header, and luckily libcurl wasn't using that symbol so it built fine.

Now, for confirming that SSL support is enabled for libcurl, run the following code:

curl_version_info_data * vinfo = curl_version_info( CURLVERSION_NOW );
if( vinfo->features & CURL_VERSION_SSL )
    // SSL support enabled
else
    // No SSL

Simple as that.

Regards.

/Robert



CURLOPT_USE_SSL

Pass a long using one of the values from below, to make libcurl use your desired level of SSL for the FTP transfer. (Added in 7.11.0)

(This option was known as CURLOPT_FTP_SSL up to 7.16.4, and the constants were known as CURLFTPSSL_*)

CURLUSESSL_NONE

Don't attempt to use SSL.

CURLUSESSL_TRY

Try using SSL, proceed as normal otherwise.

CURLUSESSL_CONTROL

Require SSL for the control connection or fail with CURLE_USE_SSL_FAILED.

CURLUSESSL_ALL

Require SSL for all communication or fail with CURLE_USE_SSL_FAILED. 

'



vc vs 格式化工具
AStyle code format

F:\tools\coding\AStyle.exe
	-A1 -tSKNfwpDj -M80 $(ItemFileName)$(ItemExt) 
	$(ItemDir) 
	勾选 ‘使用输出窗口’
	
	
	
	
	
	
	
	
	
	
赵老师：	
客户端优化：
循环里n多 (*it) 的操作，其实可以设一个临时变量 task = (*it) 的。

线程之间变量的 ++ -- 没有同步锁，应该用原子操作。	







	
	
	
	
//----------------------------------------------
FakeActor::~FakeActor()
{
    H_ASSERT( !getPatch() ); //
    //clean();
}






线程间共享数据的冲突问题和 volatile 关键字

摘要：本文涉及到多线程间数据操作方面的同步，以及volatile关键字的认识误区。从一个实际并发错误例子出发，给出了一步步解决错误的过程，同时详细说明了线程同步机制。
关键字：线程安全;thread-safe;volatile;concurrent;multithread-code;多线程编程

昨天跟悟空一起找一个服务器崩溃的bug，牵出一个比较严重的错误认识问题，现在我记录如下，以供大家参考。

我说的尽量简化点，看下面类：

[cpp]
class Message
{
	public:
		Message()
		{
			m_bIsEncryptedBeforeSend = false;
		}
		void checkEncryption()
		{
			if ( m_bIsEncryptedBeforeSend )
			{
				return;	
			}
			
			//dosomething();
			
        	m_bIsEncryptedBeforeSend = true;
		}
		//other member function
	private:
        volatile bool  m_bIsEncryptedBeforeSend;   //! count the checkEncryption is called
        //other member data field
};
[/cpp]

	这个类是一个网络消息体，在发生消息之前，网络线程会调用 Message::checkEncryption() 来检查是否已经加密，而且这段程序的意图是希望 dosomething() 部分只执行一次。这里几乎没有做任何线程安全方面的工作，于是发生昨晚的杯具。昨晚我们同一个Message会同时发给的客户端，因为是放到网络线程中处理的，所以会出现多个线程同时 Message::checkEncryption() 的情况，那么在某些时候会出现多个线程同时进入到 Message::checkEncryption() 函数体中，从而出现我们不希望看到的问题：dosomething() 这段代码被多个线程多次调用。
	
	我们找到这个问题后，很想当然的认为给这个 Message::checkEncryption() 函数入口处加一把锁就能解决问题，于是有了下面的代码：

[cpp]
class Message
{
	public:
		Message()
		{
			m_bIsEncryptedBeforeSend = false;
		}
		void checkEncryption()
		{
			m_lkEncrypt.lock();
			if ( m_bIsEncryptedBeforeSend )
			{
				m_lkEncrypt.unlock();
				return;	
			}
			
			//dosomething();
			
        	m_bIsEncryptedBeforeSend = true;
        	m_lkEncrypt.unlock();
		}
		//other member function
	private:
        volatile bool  m_bIsEncryptedBeforeSend;   //! count the checkEncryption is called
        Lock                        m_lkEncrypt;   //! lock for checkEncryption
        //other member data field        
};
[/cpp]

	加如锁之后，原来的问题看似解决了，不然，很快同样的问题继续出现，只是频率要低多了，但是还是偶尔会发生。也就是说，即使加了锁，我们还是发现 Message::checkEncryption() 函数体中的 dosomething(); 这一段代码被多个线程调用过。这是为什么呢？
	
	因为 volatile 修饰的变量仅仅是保证编译器不会优化这个变量，同时也不会放到cpu寄存器中，但似乎并没有说明必须从物理内存中取数据而不从cpu缓存取数据。昨天加锁后问题依旧出现。情况看起来只有这种可能了：
	线程A、B同时来到 Message::checkEncryption() 函数体中，其中线程A获得了锁，进入函数体，线程B等待。当线程A退出函数体释放锁，线程B再进入，由于刚刚线程B将锁相关的数据读入cpu缓存中时候顺带也将 m_bIsEncryptedBeforeSend 读入cpu缓存中，这个时候线程B访问m_bIsEncryptedBeforeSend发现是false（old value，并没有因为线程A修改了而得到刷新），于是继续执行，从而出现我们不愿看到的结果，dosomething();被执行两次。（注释：这里线程A、B可能分别在两个不同的cpu核上执行，而每个cpu核可能有自己独立的cpu缓存）。
	
	下面关于 volatile 关键字，我们顺带多说下。

	我找了很大一圈关于 volatile 关键字的资料，最终发现网上有两种截然不同的看法：
看法一：用 volatile 变量可以解决多线程中的共享数据问题
看法二：用 volatile 变量不会带来任何好处，根本不能解决多线程共享数据冲突问题，反而会因为不优化而带来性能损降。

昨天出现问题，我发现在多核cpu情况下，看法二是比较符合实际情况的。下面举一些网络上的比较权威的资料：
1. www.open-std.org Should volatile Acquire Atomicity and Thread Visibility Semantics? 
	网址：http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html ) 
	这里说了一句话：According to David Butenhof, "the use of volatile accomplishes nothing but to prevent the compiler from making useful and desirable optimizations, providing no help whatsoever in making code 'thread safe'" (comp.programming.threads posting, July 3, 1997, according to the Google archive). 翻译过来就是：根据David Butenhof所说，使用 volatile 除了阻止编译做一些有益的事情和优化，并不会达到任何目的，对于写多线程代码的线程安全问题不会提供任何帮助。
2. www.kernel.org Why the "volatile" type class should not be used
	网址：http://kernel.org/doc/Documentation/volatile-considered-harmful.txt 这里提供了一篇文章说明了 "volatile" 变量不应该被使用的原因。
		
		
	解决上述线程冲突问题，除了加锁外，我们还需要对 m_bIsEncryptedBeforeSend 变量的修改进行原子操作才能保证一个线程（该线程在cpu A核上）改了，另一个线程（该线程可能不在cpu A核而在其他核上）能知道这种更改。具体解决办法请见下面代码：
[cpp]
class Message
{
	public:
		Message()
		{
			m_bIsEncryptedBeforeSend = 0;
		}
		void checkEncryption()
		{
			m_lkEncrypt.lock();
			if( AtomicInc32( &m_nIsEncryptedBeforeSend ) > 1 )
			{
				m_lkEncrypt.unlock();
				return;	
			}
			
			//dosomething();
			
        	
        	m_lkEncrypt.unlock();
		}
		//other member function
	private:
        AtomicInt32    m_nIsEncryptedBeforeSend;   //! count the checkEncryption is called
        Lock                        m_lkEncrypt;   //! lock for checkEncryption
        //other member data field        
};
[/cpp]	

OK.本文的所涉及的code基本上伪代码，不过应该都能很容易的看懂。













test_tcp --type=server start 
test_tcp --type=client start --tcpnum=300 --msglen=50000 --msgnum=100000 --host='10.192.0.43' --port=12345

test_tcp --type=client start --tcpnum=300 --msglen=50000 --msgnum=100000 --host='10.192.0.42' --port=12345

test_tcp --type=client start --tcpnum=1 --msglen=50000 --msgnum=100000


2010.7.31号merge工作
1. http://192.168.0.8/svn/v2/common/trunk/src 				--> http://192.168.0.8/svn/v4/refactory/branches/20100628/common/src
2. http://192.168.0.8/svn/v2/common/trunk/src/hoslib/src 	--> http://192.168.0.8/svn/v4/refactory/branches/20100628/server/src/hoslib/src
3. http://192.168.0.8/svn/v2/server/trunk/src/hnetworklib	--> http://192.168.0.8/svn/v4/refactory/branches/20100628/server/src/hnetworklib
4. http://192.168.0.8/svn/v2/common/trunk/src/hlibtest		--> http://192.168.0.8/svn/v4/refactory/branches/20100628/test/hlibtest
	
2010.8.19号merge工作
1. http://192.168.0.8/svn/v2/common/trunk/src 				--> http://192.168.0.8/svn/v4/refactory/trunk/common/src
2. http://192.168.0.8/svn/v2/common/trunk/src/hoslib/src 	--> http://192.168.0.8/svn/v4/refactory/trunk/server/src/hoslib/src
3. http://192.168.0.8/svn/v2/server/trunk/src/hnetworklib	--> http://192.168.0.8/svn/v4/refactory/trunk/server/src/hnetworklib
4. http://192.168.0.8/svn/v2/common/trunk/src/hlibtest		--> http://192.168.0.8/svn/v4/refactory/trunk/test/hlibtest
5. http://192.168.0.8/svn/v2/server/trunk/src/hservercommon --> http://192.168.0.8/svn/v4/refactory/trunk/server/src/hservercommon
	
	
	
2010.9.17号merge工作
1. http://192.168.0.8/svn/v2/common/trunk/src 				--> http://192.168.0.8/svn/v4/refactory/trunk/common/src
2. http://192.168.0.8/svn/v2/common/trunk/src/hoslib/src 	--> http://192.168.0.8/svn/v4/refactory/trunk/server/src/hoslib/src
3. http://192.168.0.8/svn/v2/server/trunk/src/hnetworklib	--> http://192.168.0.8/svn/v4/refactory/trunk/server/src/hnetworklib
4. http://192.168.0.8/svn/v2/common/trunk/src/hlibtest		--> http://192.168.0.8/svn/v4/refactory/trunk/test/hlibtest
5. http://192.168.0.8/svn/v2/server/trunk/src/hservercommon --> http://192.168.0.8/svn/v4/refactory/trunk/server/src/hservercommon

http://192.168.0.8/svn/v4/refactory/trunk/server/src/hnetworklib/src
http://192.168.0.8/svn/v4/refactory/trunk/common/src/hnetworklib/include
		
	
#include "hoslib/include/HOSLibPrerequisits.h"

#include "hoslib/include/HThread.h"
#include "hoslib/include/HAsyncWorkSet.h"
#include "hoslib/include/HRingBuffer.h"
#include "hoslib/include/HEvent.h"
#include "hoslib/include/HAsyncCommand.h"

#include "hoslib/include/HMultiThreadInvokeList.h"
#include "hoslib/include/HFrameStat.h"
	
	
	
	
	
	
1. Netperf 介绍

Netperf 是一种网络性能的测量工具，主要针对基于TCP 或UDP 的传输。Netperf 根据应用的不同，可以进行不同模式的网络性能测试，即批量数据传输（bulk data transfer）模式和请求/应答（request/reponse）模式。Netperf 测试结果所反映的是一个系统能够以多快的速度向另外一个系统发送数据，以及另外一个系统能够以多块的速度接收数据。Netperf工具以 client/server 方式工作。server 端是netserver，用来侦听来自client 端的连接，client端是netperf，用来向server 发起网络测试。在 client 与server 之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果；在控制连接建立并传递了测试配置信息以后， client 与server 之间会再建立一个测试连接，用来来回传递着特殊的流量模式，以测试网络的性能。其官方网址是：http://www.netperf.org /netperf/DownloadNetperf.html测试的时候请注意，设置的测试文件的大小一定要大过你的内存(最佳为内存的两倍大小)，不然 linux 会给你的读写的内容进行缓存。会使数值非常不真实。	
	
	
	
	
hiserver.20100810.215500.tar.gz 流量控制的版本，有错误	





















图片
用户名:   密码: 登录
注册
荒野游侠vs随缘的空间
开心O(∩_∩)O~~
 
主页博客相册|个人档案 |好友
  	
查看文章
		 
【转】 转:设置CMD窗口大小的方法
2010-05-25 16:21
转载自 foxnet007
最终编辑 荒野游侠vs随缘
一、先看看在Windows的设置方法：

宽高知道
mode con cols=98 lines=35
左右怎么设【命令】


全屏怎么设【命令】[已找到]
@Echo Off
rem 批处理无所不能
echo exit |%ComSpec% /k prompt e 100 B4 00 B0 12 CD 10 B0 03 CD 10 CD 20 $_g$_q$_ |debug >nul
chcp 437 >nul
graftabl 936 >nul



二、用批处理命令来设置(下面是通过修改注册表来设置，会影响到其他批处理窗口大小，不建议使用。)

先看一使用实例：

@echo off
set rr="HKCU\Console\%%SystemRoot%%_system32_cmd.exe"

reg add %rr% /v "WindowPosition" /t REG_DWORD /d 0x010e0140 /f>nul
::WindowPosition表示窗口位置，高四位为上，低四位为左，距屏幕上沿10eH=270，距屏幕左沿140H=320。

reg add %rr% /v "ScreenBufferSize" /t REG_DWORD /d 0x000a002d /f>nul
::ScreenBufferSize表示缓冲区尺寸，高四位为高度，低四位为宽度，高aH=10行，宽2dH=45列。

reg add %rr% /v "WindowSize" /t REG_DWORD /d 0x000a002d /f>nul
::WindowSize表示窗口尺寸，高四位为高度，低四位为宽度，高aH=10行，宽2dH=45列。
::也可以用mode con cols=45 lines=10来设置窗口尺寸，cols设置宽度，lines设置高度。

if not defined ff (set ff=0&start cmd /c %0&exit)

TITLE 添加/删除开机光驱启动菜单
::title设置标题。

COLOR 8B
::color设置背景色和字体颜色

echo 大牙猫电脑维护工作室欢迎您！
pause


具体设置说明：

1、默认设置：
HKEY_CURRENT_USER\Console

2、自定义设置：
[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]

3、键及值：
"WindowPosition"=dword:00640104
"CodePage"=dword:000003a8
"FontSize"=dword:00100008
"FontFamily"=dword:00000030
"FontWeight"=dword:00000190
"HistoryNoDup"=dword:00000000
"FullScreen"=dword:00000000
"ScreenColors"=dword:000000ce
"ScreenBufferSize"=dword:12c0050

4、键值意义：
各键值均为十六进制表示
窗口位置-----WindowPosition---高四位为上，低四位为左。
                           如00640104，即距屏幕上沿64H=100，距屏幕左沿104H=260
字体大小-----FontSize---------高四位为字高，低四位为字宽
                           如00100008，即字体宽×高=08H×10H=8×16
全屏幕-------FullScreen-------0:窗口 1:全屏幕(此时WindowPosition失效)
窗口尺寸-----WindowSize-------高四位为高度，低四位为宽度
                           默认00190050，即高19H=25行，宽50H=80列
缓冲区尺寸---ScreenBufferSize-高四位为高度，低四位为宽度
                           默认012c0050，即高12cH=300行，宽50H=80列
字体颜色-----ScreenColors-----低两位同color设置中的字体颜色值
字体类型-----FontFamily-------36:新宋体 30:点阵字体
当前代码页---CodePage---------默认3a8H=936:ANSI/OEM-简体中文GBK
丢弃旧副本---HistoryNoDup-----0:不丢弃 1:丢弃旧副本

5、自定义与默认关系：
系统首先在自定义里面查找相关设置，若自定义中没有，则到默认里面查找。
即自定义优先级高于默认。

6、批处理设定窗口属性
set rr="HKCU\Console\%%SystemRoot%%_system32_cmd.exe"
reg delete %rr% /f>nul
reg add %rr% /v "WindowPosition" /t REG_DWORD /d 0x00640104 /f>nul
reg add %rr% /v "WindowSize" /t REG_DWORD /d 0x00190050 /f>nul
reg add %rr% /v "ScreenBufferSize" /t REG_DWORD /d 0x00190050 /f>nul
reg add %rr% /v "FullScreen" /t REG_DWORD /d 0x00000001 /f>nul
reg add %rr% /v "FontSize" /t REG_DWORD /d 0x00100008 /f>nul

7、字体大小：
(1)点阵字体(较小)
3×5-------00050003
5×8-------00080005
6×12------000c0006
6×13------000d0006
8×16------00100008
8×18------00120008
10×20-----0014000a
10×22-----0016000a
12×27-----001b000c
(2)新宋体(较大)
6----00060000---3*7
8----00080000---4*9
10---000a0000---5*11
12---000c0000---6*14
14---000e0000---7*16
16---00100000---8*18
18---00120000---9*21
20---00140000---10*23
24---00180000---12*27
28---001c0000---14*32
36---00240000---18*41
72---00480000---36*82

以上是自定义cmd窗口属性的基本知识，下面提供一个实例，是一个小游戏：猜数字。

@echo off
set rr="HKCU\Console\%%SystemRoot%%_system32_cmd.exe"
reg add %rr% /v "WindowPosition" /t REG_DWORD /d 0x0064020b /f>nul
reg add %rr% /v "WindowSize" /t REG_DWORD /d 0x000e0015 /f>nul
reg add %rr% /v "ScreenBufferSize" /t REG_DWORD /d 0x000e0015 /f>nul
if not defined ff (set ff=0&start cmd /c %0&exit)
::mode con cols=21 lines=14
title 猜数字
setlocal enabledelayedexpansion
cd /d %TEMP%

>tmp.bat echo @echo off
>>tmp.bat echo title 输入数字
>>tmp.bat echo for /l %%%%i in (1,1,6) do echo.
>>tmp.bat echo set /p num=输入数字：
>>tmp.bat echo echo %%num%%^>tm.tmp
>>tmp.bat echo exit

:main
cls
set times=0
echo 次 数字   状况
:again
set n1=%random:~-1%
set n2=
set n3=
set n4=
:value
set n=%random:~-1%
if "%n2%"=="" if %n% NEQ %n1% set n2=%n%
if "%n3%"=="" if %n% NEQ %n1% if %n% NEQ %n2% set n3=%n%
if "%n4%"=="" if %n% NEQ %n1% if %n% NEQ %n2% if %n% NEQ %n3% set n4=%n%
if "%n4%"=="" goto :value
::echo %n1%,%n2%,%n3%,%n4%
:check
if %times% EQU 8 goto :end
set A=0&set B=0&set m=0
reg add %rr% /v "WindowPosition" /t REG_DWORD /d 0x0064015c /f>nul
reg add %rr% /v "WindowSize" /t REG_DWORD /d 0x000e0015 /f>nul
reg add %rr% /v "ScreenBufferSize" /t REG_DWORD /d 0x000e0015 /f>nul
start /wait cmd /k tmp.bat
reg delete %rr% /f>nul
set /p num=<tm.tmp
del tm.tmp&set /a times+=1
if /i "%num%"=="exit" (del tm.tmp&del tmp.bat&exit)
for %%i in (%n1%,%n2%,%n3%,%n4%) do (
(echo %num%|find "%%i")>nul&&(
set /a B+=1
call set k=%%num:~!m!,1%%
if "%%i"=="!k!" set /a A+=1
)&set /a m+=1
)
echo %times% %num%   %A%A%B%B
if %A% NEQ 4 goto :check
del tmp.bat
echo   恭喜你，答对了！
pause>nul
exit

:end
echo.
echo     你已试了8次了！
echo    答案是%n1%%n2%%n3%%n4%
echo    再来一次吧！
set /p ff=
if /i "%ff%"=="N" (del tmp.bat&exit)
goto :main

三、通过第三方软件SW.exe来设置CMD窗口的位置：（文章转自这里）

使用方法:
SW [编号]                 (1个参数->当前窗口)
SW [编号] [指定窗口标题]   (2个参数->指定标题窗口||若含空格键,请用双引号括起)
(附:窗体前置)SW [指定窗口标题] [屏幕x坐标] [屏幕y坐标] [窗口宽度] [窗口高度]

可选参数编号
       0   隐藏窗口
       1   显示窗口
       2   最大化窗口
       3   最小化窗口
       4   闪烁窗口
               (返还值0表示失败,返还值1表示成功!)
例子:
SW 2
SW 4 我的电脑
SW 命令提示符 0 0 600 500

类别：dos相关 | | 添加到搜藏 | 分享到i贴吧 | 浏览(73) | 评论 (0)
 
上一篇：netstat命令详解    下一篇：windows下的EXE文件
 
最近读者：
	登录后，您就出现在这里。				
 	 	nkfeiyang	hankcs	lushaojin	
 
网友评论：
发表评论：
  	
内　容： 	
  	
  	    取消回复

  	  	 

?2010 Baidu



IB破解 
关闭IB的服务：BuildService.exe 和 IncrediBuild Agent。 然后将下面两个文件放到同一个文件夹下面，双击 “IB3.51_crack.exe” 即可破解
IB3.51_crack.exe
IncrediBuild_keymaker.exe














 转载  去掉Visual Studio 2005的IntelliSense功能 收藏
标签： vs.net  2005  intellisense  VC++ 

VS的IntelliSense功能类似其他IDE中的auto-completion,也就是能够自动补全。

其实是为了程序员快速的书写代码，是个不错的功能，但是对C++这样的语言，需要语法分析源代码，每更改一次code都有可能引发 IntelliSense更新.ncb文件，ncb文件很容易就更新得很大。而IntelliSense很不识相，往往不合时宜的更新，还会占用很多时间。对于一个包含多个Projects的Solution，VS环境很容易僵死（CPU占用率100%），左下角一个"Updating IntelliSense"的提示，右边出现一个进度条(进度很慢)。
很可惜，VS到2005还没有Disable掉这个功能的UI。（网上有说菜单：Tools->Options 对话框左：如果仅需修改ide对c/c++项目的设置，选Text Editor->C/C++->General 右：Auto list members：提示成员
Parameter information：提示参数），没有去尝试，因为我用下面的方法去解决了。
下面是一些在网上搜索到的方法：
方法一:
IntelliSense会不断更新Solution的.ncb文件，把这个文件弄成Read-only,然后确认一堆的对话框；
方法二：
那需要来狠的，直接把VS安装目录下的VC/vcpackages\feacp.dll去掉；（推荐使用）
方法三：
关闭VC，然后删除sln文件同级目录下的同名ncb文件，再次加载解决方案。IntelliSense在很短时间内完成，问题解决！（有试过，但不知时间长了，更新是否变慢！？ncb文件是否会增大！？）
注释:如果使用方法二,可能造成的问题是,工程的属性出错,导致无法创建某些类,我碰到的情况是,ATL工程在添加COM+类时,提示只有 atl工程或MFC常规DLL工程才能添加COM+ 1.0 Class.如果碰到这样的情况,应该关闭VS,将feacp.dll文件放回原目录,重新打开vs加载项目即可




KC_F5进入地形编辑 调用 ---> void CHipihiWorld::ToEditPatchMode()
之后鼠标消息、按键消息转发到 s_pTerrainEditor （　s_pUITargetManager->setActiveTool( s_pTerrainEditor )　这个实现的）
然后，地形编辑界面打开　m_pTerrainEditWnd->Show();　












refactor

FileUtil::getFiles ---> add listFiles
DynLib dlclose dlload ----> add tow method to open and close dll instead of using MICRO
void PatchModuleManager::loadPatchModulesInDirectory( const OSLib::StringA& strDirName )   --> using FileUtil::getFiles
NetUtility line:127 multi-line comments
	
	
class _EXPORT_EDIT CommandManager :  public GUI::CUICommandHUBInterface, public OSLib::Singleton<CommandManager>
{
public:
	// Key definition.
	struct Key
	{
		union
		{
			struct{
				OSLib::u8    nKey;
				OSLib::u8    bCtl;
				OSLib::u8    bAlt;
				OSLib::u8    bShift;
			};
			OSLib::u32       nShort;
		};

		//! Lesser
		bool operator < ( const Key& oth )const
		{
			return nShort < oth.nShort;
		}
	};
processKeyEvent( irr::KeyCode nKey, bool bCtl, bool bAtl )  --->  add bShift
	
	
能否考虑将 AppShell 和 CommandManager结合下		

registerPatchSpace( H_NEW GridMainSpace( Common::PT_LR ) ); 里面的数组可否考虑用 map？
	

	



{"code":"ok","returncode":"1000","list":[{"id":"1001","location":"","name":"博物馆"},{"id":"1191494376","location":"0,0,0","name":"aaaaaaaaaaaa"},{"id":"1364910797","location":"0,0,0","name":"bbbbbbbbbbbbb"},{"id":"189208881","location":"0,0,0","name":"cccccccccccccc"},{"id":"18547353","location":"0,0,0","name":"dddddddddd"},{"id":"991483799","location":"0,0,0","name":"eeeeeeeeeeee"},{"id":"1614979092","location":"0,0,0","name":"666666666"}]}	
	
	
taosheng(陶盛 - 二郎神) 18:57:18
if (pms_patch_type == 1001)
	db_patch_id = (pms_patch_y - 5000) << 16 + pms_path_x - 5000;
fi
正确的换算算法是这样的
可以从 pms的patch x y 换算成 张亮库德 patchid









curl
	 //! 被我们修改了，禁用线程方式获取主机IP。
#ifdef _WIN32
#	ifdef USE_THREADING_GETHOSTBYNAME
		//! gethostbyname_thread assertion. 
#		undef USE_THREADING_GETHOSTBYNAME
#	endif
#endif










背包系统 疑问
1、一个物品，放到土地上后，背包中就没有了，如果想在背包中也放一份，是拷贝还是引用？

系统背包-----所有人公共的背包，一个特殊的用户背包。其他人可以读取这个背包，但不能修改这个背包。
个人背包
回收站--也是一个特殊的目录
根目录也是一个特殊的目录（给定为

目录也是一个特殊物品

sql item_table
	itemid --uuid
	userid --u64
	dirid --uuid,a special item
 
 根目录uuid userid+1
 回收站uuid userid+2
 
背包内：增、删、改、查、复制、移动
背包间：赠送、复制
 

vc2005中文版有一个文件无论如何打不上断点
解决办法：
把文件中的代码复制下来，删除文件，并从工程中删除，新建一个同名文件，粘贴。试试  
文件的编码格式不匹配造成的;修改步骤: 菜单->文件->XXX文件另存为->编码保存(保存按钮旁边的下拉菜单)->Unicode (UTF-8 带签名)->确定 今天遇到这个问题，试用了很多方法无效，用以上方法解决了



最近一工程中，在调试的时候，有些cpp文件都可以设置断点并且跟进去，但是有一个cpp文件总是不能设置断点，提示“当前不会命中断点。源代码与原始版本不同。” 重新更换过n次文件都不起作用，然后在goole搜索此类类似问题，找到下篇文章，然后我把那个cpp文件用记事本打开，另存为unicode格式，再重新编译，最后问题解决！也可以更改vs2005的设置，选项->常规，将要求源文件与原始版本完全匹配的勾取消就可以了！

清理整个解决方案，重新编译，无效。删除整个目录，从SubVersion服务器上Down下来重新来过，一样无效。上网搜索，未果。郁闷地放手了。

修一个Bug，提交，然后更新了一下，编译，运行，发现我也染上这个症状了――只有那个文件无法插入断点。倒有些安心了，看来不是VC的Bug，而是源代码的问题。把这个文件回滚到更新前的版本，果然就没问题了。更新到下一个版本，问题就出来了。查看改动，没瞧出来什么。忽然发现有一个不常见的警告：“warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失”。呵呵，应该就是它了。

警告有两个，一个是文件的，不带行号，另一个带行号。那一行是一个case语句，最后加了一句中文注释。把注释删掉，问题解决。把代码拷贝到 UltraEdit中看十六进制代码，逐个字节滤过去，没发现什么奇怪的。然后开始逐步逼近问题，把注释前后汉字逐个拿掉，直到问题消失，最后剩下来的核心词是“即时消息”，搜索这个词，果然在整个项目里只有一个。在这个词前面增、删一个空格，问题就消失。郁闷的是把同一行代码拷贝到其他文件、位置都不会有这个问题。















土地亮度调节不起作用的bug查找过程：
1、看数据有没有调节， PatchBinData.getShine( u32 index )
2、void CZgGMMPatchT::UpdateVertex( void )
	shine = getData()->getShine( index );
	m_pVertex[i].TCoords.Y = shine;
3、是通过 TCoords.Y 这个参数传入到 shader 中
4、去 shader Terrain.cgfx 中查找
	struct VS_INPUT
	{
		float4 Pos        : POSITION;   // vertex position        顶点位置
		float4 Normal     : NORMAL;     // vertex normal          顶点法线
		float4 Diffuse    : COLOR0;     // vertex diffuse         细节纹理比例
		float2 Tex1       : TEXCOORD0;  // vertex texture coords0 全局纹理坐标
		float2 Tex2       : TEXCOORD1;  // vertex texture coords1 水面高度（U通道）
	};
	发现 TEXCOORD0 对于与 Tex1，那么亮度值将会传入到 Tex1.y 中
	
	随便说下 struct S3DVertex2TCoords 与 shader中的struct VS_INPUT 的相应字段一一对应
	struct S3DVertex2TCoords
	{
		core::vector3df Pos;
		core::vector3df Normal;
		SColor Color;
		core::vector2d<f32> TCoords;
		core::vector2d<f32> TCoords2;
	};
	
5、在 Terrain.cgfx 中
	VS_OUTPUT VS_Main(VS_INPUT Input)  -> Output.Tex1.z= Input.Tex1.y;  
	由外面传入的 shine 亮度值保存在 Output.Tex1.z 中了，这个Output会作为输入参数传给 PS_Main
	
6、	在  PS_Main_0 中，会调用  MakeColor_0 

7、 在 MakeColor_0 中 
	Color=(TexDetail1*Input.Tex5.y+TexDetail2*Input.Tex5.x)
		     *(Input.Diffuse+g_vShineColor*Input.Tex1.z);
			 
	那么 g_vShineColor 的值会影响亮度值
	
8、回到程序中检查 g_vShineColor 对应的
	
	
	
	
	
	
//! \brief 
//! \param $MethodArg$ - 
//! \return $SymbolType$ - 



//************************************
// Method:    $SymbolName$
// FullName:  $SymbolContext$
// Access:    $SymbolVirtual$$SymbolPrivileges$$SymbolStatic$
// Returns:   $SymbolType$
// Qualifier: $MethodQualifier$
// Parameter: $MethodArg$
//************************************	



http://192.168.0.43/fws/admin/upload.html
http://192.168.0.43/fws/admin/view.php
http://192.168.0.43/fws/lock.php?type=aaa&uuid=d943d2c68e25b378f83a9ad734c0e1fa&userid=1003&version=1
http://v2r.hipihi.com/fws/lock.php?type=aaaaaa&uuid=f908c0bcf8148d3eb43591b752fada4a&userid=1003&version=1

	
	
	
	
	
	
Home ? Language IDEs ? CDT ? All files are recompiled even if they are not modified (All files are recompiled even if they are not modified)
		
Nothing better like publish the topic and discover the problem. In my case the reason why the files were recompiled every time was enabling the parallel build option and set 2 parallels jobs. I have set use optimal jobs number and now it works perfectly. So it seems there is some kind of error when the number of jobs is manually set.	