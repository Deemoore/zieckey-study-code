Shading 着色
multisampling 多重采样或反走样

顶点以逆时针方向出现在屏幕上的多边形称为正面。可以调用 glFrontFace 来指定哪种方向为正面。GL_CCW，GL_CW

OpenGL中的几种变换：
我们生活在一个三维的世界――如果要观察一个物体，我们可以：
1、从不同的位置去观察它。（视点变换/视图变换，gluLookAt）
2、移动或者旋转它，当然了，如果它只是计算机里面的物体，我们还可以放大或缩小它。（模型变换）
3、如果把物体画下来，我们可以选择：是否需要一种“近大远小”的透视效果。另外，我们可能只希望看到物体的一部分，而不是全部（剪裁）。（投影变换）
4、我们可能希望把整个看到的图形画下来，但它只占据纸张的一部分，而不是全部。（视口变换）
这些，都可以在OpenGL中实现。


如何看待变换：
注意我们都是说“与XX相乘”，而不是直接说“这个函数就是旋转”或者“这个函数就是移动”，这是有原因的，马上就会讲到。
假设当前矩阵为单位矩阵，然后先乘以一个表示旋转的矩阵R，再乘以一个表示移动的矩阵T，最后得到的矩阵再乘上每一个顶点的坐标矩阵v。所以，经过变换得到的顶点坐标就是 ((RT)v)。由于矩阵乘法的结合率，((RT)v) = (R(Tv))，换句话说，实际上是先进行移动，然后进行旋转。
即：实际变换的顺序与代码中写的顺序是相反的。
由于“先移动后旋转”和“先旋转后移动”得到的结果很可能不同，初学的时候需要特别注意这一点。


深度缓存：
深度缓存的工作原理是：将深度（离观察面，通常就是近裁剪面）的距离和和窗口中每一个像素关联起来，首先，使用 glClear( GL_DEPTH_BUFFER_BIT ) 将所有像素的深度值设置为最大的可能距离（通常为远裁剪面）这样便可以以任意顺序绘制场景中的物体。如果深度缓存被启用，则在绘制每一个新的像素之前，首先将其深度同原像素中存储的深度进行比较，如果新像素更近（更靠前），就将其颜色值和深度值替换原有的值。














裁剪变换
在OpenGL中，空间物体的三维裁剪变换包括两个部分：视景体裁剪和附加平面裁剪。视
景体裁剪已经包含在投影变换里，前面已述，这里不再重复。下面简单讲一下平面裁剪函数
的用法。
除了视景体定义的六个裁剪平面（上、下、左、右、前、后）外，用户还可自己再定义
一个或多个附加裁剪平面，以去掉场景中无关的目标，
    附加平面裁剪函数为：
void glClipPlane(GLenum plane,Const GLdouble *equation);
函数定义一个附加的裁剪平面。其中参数equation指向一个拥有四个系数值的数组，这
四个系数分别是裁剪平面Ax+By+Cz+D=0 的A、B、C、D值。因此，由这四个系数就能确定一
个裁剪平面。参数plane 是GL_CLIP_PLANEi(i=0,1,...)，指定裁剪面号。
在调用附加裁剪函数之前，必须先启动glEnable(GL_CLIP_PLANEi)，使得当前所定义的
裁剪平面有效；当不再调用某个附加裁剪平面时，可用glDisable(GL_CLIP_PLANEi)关闭相
应的附加裁剪功能。












gluLookAt(GLdoble eyex,GLdouble eyey,GLdouble eyez,GLdouble centerx,GLdouble centery,GLdouble centerz,GLdouble upx,GLdouble upy,GLdouble upz);
它共接受三对坐标,
分别为eye,center,up
故名思义,eye表示我们眼睛在"世界坐标系"中的位置,
center表示眼睛"看"的那个点的坐标,
最后那个up坐标表示观察者本身的方向,如果将观察点比喻成我们的眼睛,那么这个up则表示我们是正立还是倒立异或某一个角度在看,所看的影像大不相同,故此时需要指明我们现在正立,那么X,Z轴为0,Y轴为正即可,通常将其设置为1,只要表示一个向上的向量(方向)即可
球是画在世界坐标系的原点上的,即O(0,0,0)坐标上,我们的眼睛位于观察点A(0,0,100),Z轴向屏幕里看去的方向为负,屏幕外我们的位置,Z轴为正值,其实很好理解,即我们距离原点的距离,设置100,将观察到如下图所示的影像
如果我们向前或向后移动,则相应的图像会变大或变小,这里其实就是运用了透视原理,近处的物体大,远处的物体小,实际物体的大小是不变的,
同理改变center坐标(眼睛看去的那个点,可简单理解为视线的终点)也会影响球的大小,同样可以认为是改变了物体与观察点的距离所致,
最后那个up坐标表示观察者本身的方向,如果将观察点比喻成我们的眼睛,那么这个up则表示我们是正立还是倒立异或某一个角度在看,所看的影像大不相同,故此时需要指明我们现在正立,那么X,Z轴为0,Y轴为正即可,通常将其设置为1,只要表示一个向上的向量(方向)即可,我们指定0.1f或0.00001f异或1000.0f,效果是一样的,只要能表示方向即可,
 
 
gluPerspective(GLdouble fovy,GLdouble aspect,GLdouble zNear,GLdouble zFar)
一个一个来,首先得设置gluPerspective,来看看它的参数都表示什么意思
fovy,这个最难理解,我的理解是,眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,相同的场景，fovy大的话，场景在大视野里看起来就比较小，同理，fovy小的话，场景看起来就比较大。
aspect,这个好理解,就是实际窗口的纵横比,即x/y
zNear,这个呢,表示你近处,的裁面,
zFar表示远处的裁面,
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
OpenGL相机控制 














void glLightfv(
    GLenum light,
    GLenum pname,
    const GLfloat *params
);

GLfloat lightpos[] = { 50,50,100, 1};
如果是光线位置，如：glLightfv( GL_LIGHT0, GL_POSITION, lightpos );
	如果lightpos的最后一个参数是0，表明该光线从无限远处沿着这个数组指定的向量射过来。
	如果lightpos的最后一个参数是1，表明该数组指定的坐标就是光源的位置
	
	
	
	
环境光：
环境光是指光源间接对物体的影响，是在物体和环境之间多次反射，最终达到平衡时的一种光。我们近似地认为同一环境下的环境光，其光强分布是均匀的，它在任何一个方向上的分布都相同。例如，透过厚厚云层的阳光就可以称为环境光。	


在OpenGL简单光照模型中的几种光分为：
	发射光（Emitted Light，又称为辐射光）
	环境光（Ambient Light）
	散射光（Diffuse Light，又称为漫射光）
	镜面反射光（Specular Light）
　　发射光是最简单的一种光，它直接从物体发出并且不受任何光源影响。
　　环境光是由光源发出经环境多次散射而无法确定其方向的光，即似乎来自所有方向。一般说来，房间里的环境光成分要多些，户外的相反要少得多，因为大部分光按相同方向照射，而且在户外很少有其他物体反射的光。当环境光照到曲面上时，它在各个方向上均等地发散（类似于无影灯光）。
　　散射光来自一个方向，它垂直于物体时比倾斜时更明亮。一旦它照射到物体上，则在各个方向上均匀地发散出去。于是，无论视点在哪里它都一样亮。来自特定位置和特定方向的任何光，都可能有散射成分。
　　镜面反射光来自特定方向并沿另一方向反射出去，一个平行激光束在高质量的镜面上产生100%的镜面反射。光亮的金属和塑料具有很高非反射成分，而象粉笔和地毯等几乎没有反射成分。因此，三某种意义上讲，物体的反射程度等同于其上的光强（或光亮度）。



OpenGL用材质对光的红、绿、蓝三原色的反射率来近似定义材质的颜色。象光源一样，材质颜色也分成环境、漫反射和镜面反射成分，它们决定了材质对环境光、散射光和镜面反射光的反射程度。在进行光照计算时，材质对环境光的反射率与每个进入光源的环境光结合，对散射光的反射率与每个进入光源的散射光结合，对镜面光的反射率与每个进入光源的镜面反射光结合。对环境光与散射光的反射程度决定了材质的颜色，并且它们很相似。对镜面反射光的反射率通常是白色或灰色（即对镜面反射光中红、绿、蓝的反射率相同）。镜面反射高光最亮的地方将变成具有光源镜面光强度的颜色。例如一个光亮的红色塑料球，球的大部分表现为红色，光亮的高光将是白色的。





FreeImage_GetWidth 返回bitmap的象素宽度
FreeImage_GetHeigth 返回bitmap的象素高度
FreeImage_GetPitch 返回bitmap的宽度的字节数，为了性能考虑，返回结果是以4字节对齐后的值
那么 pitch 等于 pixelwidth * pixelbytes 的4字节对齐后的值。
例如，象素宽度为10，每个像素用3字节表示，那么 pitch 的值为 10×3 再4字节对齐为 32，pitch=32








对画面色彩没有影响,glPixelStorei (GL_UNPACK_ALIGNMENT, 1)控制的是所读取的图像数据的行对齐方式.
默认4字节对齐,即一个行的图像数据字节数必须是4的整数倍. 即对RGB 3字节象素而言,若一行10个象素,30个字节,在4字节对齐模式下,OpenGL会读取32个字节的行数据.若不加注意,会导致glTexImage中系函数的读取越界,从而全面崩溃.
