QtEmbedded在嵌入式Linux系统- -
                                       

作者：北京航空航天大学 徐广毅 张晓林 崔迎炜 蒋交军
引言

   

随着嵌入式Linux应用的不断发展，嵌入式处理器运算能力的不断增强，越来越多的嵌入式设备开始采用较为复杂的GUI系统，手持设备中的GUI系统发展得非常迅速。传统的GUI系统，如Microwindows等，由于项目规模较小、功能较为薄弱，缺乏等三方软件开发的支持等诸多原因，在比较高级的手持或移动终端设备（如PDA、Smart-Phone、车载导航系统）中应用较少。

QtEmbedded是著名的Qt库开发商Trolltech公司开发的面向嵌入式系统的Qt版本，开发人员多为KDE项目的核心开发人员。许多基于Qt的X Window程序可以非常方便地移植到QtEmbedded上，与X11版本的Qt在最大程度上接口兼容，延续了在X上的强大功能，在底层彻底摒弃了X lib，仅采用framebuffer作为底层图形接口。QtEmbedded类库完全采用C++封装。丰富的控件资源和较好的可移植性是QtEmbedded最为优秀的一方面，使用X下的开发工具Qt Designer可以直接开发基于QtEmbedded的UI（用户操作接口）界面。越来越多的第三方软件公司也开始采用QtEmbedded开发嵌入式Linux下的应用软件。其中非常著名的Qt Palmtop Environment（Qtopia）早期是一个第三方的开源项目，并已经成功应用于多款高档PDA。Trolltech公司针对Smart-Phone中的应用需求，于2004年5月底发布了Qtopia的Phone版本。

1 QtEmbedded的实现技术基础分析

横向来看，由于发布的版权问题，QtEmbedded采用两种方式进行发布：在GPL协议下发布的free版与专门针对商业应用的commercial版本。二者除了发布方式外，在源码上没有任何区别。纵向看来，当前主流的版本为Qtopia的2.x系列与最新的3.0x系列。其中2.0版本系统较多地应用于采用Qtopia作为高档PDA主界面的应用中；3.x版本系列则应用于功能相对单一，但需要高级GUI图形支持的场合，如Volvo公司的远程公交信息系统。图1为QtEmbedded的实现结构。

3.x版本系列的QtEmbedded相对于2.x版本系统增加了许多新的模块，如SQL数据库查询模块等。几乎所有2.x版本中原有的类库，在3.x版本中都得到极大程度的增强。这就极大地缩短了应用软件的开发时间，扩大了QtEmbedded的应用范围。


   在代码设计上，QtEmbedded巧妙地利用了C++独有的机制，如继承、多态、模板等，具体实现非常灵活。但其底层代码由于追求与多种系统、多种硬件的兼容，代码补丁较多，风格稍显混乱。 

1．1 QtEmbedded的图形引擎实现基础

QtEmbedded的底层图形引擎基于framebuffer。Framebuffer是在Linux内核架构版本2.2以后推出的标准显示设备驱动接口。采用mmap系统调用，可以将framebuffer的显示缓存映射为可连续访问的一段内存储针。由于目前比较高级的ARM体系的嵌入式CPU中大多集成了LCD控制模块，LCD控制模块一般采用双DMA控制器组成的专用DMA通道。其中一个DMA可以自动从一个数据结构队列中取出并装入新的参数，直到整个队列中的DMA操作都已完成为止。另外一个DMA与画面缓冲区相关，这部分由两个DMA控制器交替执行，并每次都自动按照预定的规则改变参数。虽然使用了双DMA，但这两个DMA控制器的交替使用对于CPU来说是不可见的。CPU所获得的只是由两个DMA组成的一个“通道”而已。

Framebuffer驱动程序的实现分为两个方面：一方面是对LCD及其相关部分的初始化，包括画在缓冲区的创建和对DMA通道的设置；另外一方面是对画面缓冲区的读写，具体到代码为read、write、lseek等系统调用接口。至于将画面缓冲区的内容输出到LCD显示屏上，则由硬件自动完成。对于软件来说是透明的。当对于DMA通道和画面缓冲区设置完成后，DMA开始正常工作，并将缓冲区中的内容不断发送到LCD上。这个过程是基于DMA对于LCD的不断刷新的。基于该特性，framebuffer驱动程序必须将画面缓冲区的存储空间（物理空间）重新映射到一个不加高缓存和写缓存的虚拟地址区间中，这样能才保证应用程序通过mmap将该缓存映射到用户空间后，对于该画面缓存的写操作能够实时的体现在LCD上。

在QtEmbedded中，Qscreen类为抽象出的底层显示设备基类，其中声明了对于显示设备的基本描述和操作方式，如打开、关闭、获得显示能力、创建GFX操作对象等。另外一个重要的基类是QGfx类。该类抽象出对于显示设备的具体操作接口（图形设备环境），如选择画刷、画线、画矩形、alpha操作等。以上两个基类是QtEmbedded图形引擎的底层抽象。其中所有具体函数基本都是虚函数，QtEmbedded对于具体的显示设备，如Linux的framebuffer、Qt Virtual Framebuffer做的抽象接口类全都由此继承并重载基类中的虚函数实现。图2为QtEmbedded中底层图形引擎实现结构。


    在图2中，对于基本的framebuffer设备，QtEmbedded用QlinuxFbScreen来处理。针对具体显示硬件（如Mach卡、Voodoo卡）的加速特性，QtEmbedded从QlinuxFbScreen和图形设备环境模板类QgfxRasterdepth,type继承出相应子类，并针对相应硬件重载相关虚函数。 

QtEmbedded在体系上为CS结构，任何一个QtEmbedded程序都可以作为系统中唯一的一个GUI Server存在。当应用程序首次以系统GUI Server的方式加载时，将建立QWSServer实体。此时调用QWSServeropenDisplay()函数创建窗体，在QWSServeropenDisplay（）中对QWSDisplay：：Data中的init()加以调用；根据QgfxDriverFactory实体中的定义（QLinuxFbScreen）设置关键的Qscreen指针qt_screen并调用connect()打开显示设备（devfb0）。在QWSServer中所有对于显示设备的调用都由qt_screen发起。至此完成了QtEmbedded中QWSServer的图形发生引擎的创建。当系统中建立好GUI Server后，其它需要运行的QtEmbedded程序在加载后采用共享内存及有名管道的进程通信方式，以同步访问模式获得对共享资源framebuffer设备的访问权。

1.2 QtEmbedded的事件驱动基础

QtEmbedded中与用户输入事件相关的信号，是建立在对底层输入设备的接口调用之上的。QtEmbedded中的输入设备，分为鼠标类与键盘类。以3.x版本系列为例，其中鼠标设备的抽象基类为QWSMouse Handler，从该类又重新派生出一些具体的鼠标类设备的实现类。该版本系列的QtEmbedded中，鼠标类设备的派生结构如图3所示。

与图形发生引擎加载方式类似的，在系统加载构造QWSServer时，调用QWSServeropenMouse与QWSServeropenKeyboard函数。这两个函数分别调用QmouseDriverFactorycreate()与QkbdDriverFactorycreate()函数。这时会根据Linux系统的环境变量QWS_MOUSE_PROTO与QWS_KEYBOARD获得鼠标类设备和键盘类设备的设备类型和设备节点。打开相应设备并返回相应设备的基类句柄指针给系统，系统通过将该基类指令强制转换为对应的具体子类设备指针，获得对具体鼠标类设备和键盘类设备的调用操作。

值得注意的是，虽然几乎鼠标类设备的功能上基本一致，但由于触摸屏和鼠标底层接口并不一样，会造成对上层接口的不一致。举例来讲，从鼠标驱动接口中几乎不会得到绝对位置信息，一般只会读到相对移动量。另外，鼠标的移动速度也需要考虑在内，而触摸屏接口则几乎是清一色的绝对位置信息和压力信息。针对此类差别，QtEmbedded将同一类设备的接口部分也给予区别和抽象，具体实现在QmouseDriverInterface类中。键盘类设备也存在类似问题，同样引入了QkbdDriver Inteface来解决。具体实现此处暂不多述。

2 QtEmbedded的移植与应用

针对QtEmbedded的实现特点，移植该嵌入式GUI系统一般分为以下几个步骤：

①设计硬件开发平台，并移植Linux操作系统；

②采用静态链接进Linux内核的方式，根据该平台显示设备的显示能力，开发framebuffer驱动程序；

③开发针对该平台的鼠标类设备驱动程序，一般为触摸屏或USB鼠标；

④开发针对该平台的键盘类设备驱动程序，一般为板载按钮或USB键盘（该部分可选）；

⑤根据framebuffer驱动程序接口，选择并修改QtEmbedded中的QlinuxFbScreen和QgfxRaster类；

⑥根据鼠标类设备驱动程序，实现该类设备在QtEmbedded中的操作接口；

⑦根据键盘类设备驱动程序，实现该类设备在QtEmbedded中的操作接口（该部分可选）；

⑧根据需要选择QtEmbedded的配置选项，交叉编译QtEmbedded的动态库；

⑨交叉编译QtEmbedded中的Example测试程序，在目标平台上运行测试。

Framebuffer设备驱动程序提供出的接口是标准的，除了注意endian问题外，配置QtEmbedded时选择相应的色彩深度支持即可，因此该部分的移植难点就在于framebuffer驱动程序的实现。QtEmbedded部分的QWSServer打开dev中的framebuffer设备后读出相应的显示能力（屏幕尺寸、显示色彩深度），模板QgfxRasterdepth.type将根据色彩深度在用户空间设备创建出与显示缓存同样大小的缓冲作为双缓冲，并采用正确方式进行显示。


2.1 在PXA255平台上移植和应用 

在笔者参与设计的某Smart-Phone开发平台中，GUI系统实现方案采用了QtEmbedded 2.3.7和Qtopia 1.7.0（基于QtEmbedded 2.x系列的手持套件），硬件平台采用了基于Intel XScale PXA255处理器的嵌入式开发系统。该开发系统采用640×480分辨率的TFT LCD和PXA255内部LCD控制模块作为显示设备，ADS7846N作为外部电阻式触摸屏控制器；另外，采用了五方向按键作为板载键盘。由于该系统采用了ISP1161作为USB Host控制器，较好地支持了USB接口的键盘和鼠标，操作系统为ARM Linux 2.4.19。参考Linux 2.4.19内核目录driversinput部分，可以按照标准内核中input device接口设计实现触摸屏和键盘，在实现了基于ISP1161的EHCI驱动程序后，移植标准的USB接口的人机界面设备驱动HID和USB键盘、鼠标的驱动程序后，可以获得对于该类设备的调用接口。此过程不属本文讨论范畴，此处暂不多述。

QtEmbedded 2.x系列对于输入设备的底层接口与3.x系列不同，触摸屏设备和键盘设备需要根据具体的驱动程序接口在QtEmbedded中设备实现对应的设备操作类。其中对应于鼠标类设备的实现位于srckernelqmouse_qws.cpp中。由于触摸屏在实现原理上存在着AD量化误差的问题，因此所有的触摸屏接口实现类需要从特殊的QcalibratedMouseHandler继承，并获得校正功能。

QtEmbedded 2.x中对于键盘响应的实现函数位于srckernelqkeyboard_qws.cpp中。在qkeyboard_qws.h中，定义了键盘类设备接口的基类QWSKeyboardHandler，移植时需要根据键盘驱动程序从该类派生出实现类，实现键盘事件处理函数processKeyEvent()，并在QWSServernewKeyboardHandler函数中注册自己的键盘类设备即可。其中对于点击键的键码定义在QtEmbedded的命名空间――srckernelqnamespace.h中。

图4为笔者在该Smart-Phone开发平台上移植QtEmbedded 2.3.7和Qtopia 1.7.0后显示的截图。

2.2 在MC9328平台上移植和应用

在某车载导航辅助系统的开发平台设计中，采用了QtEmbedded 3.3.2版本作为其GUI系统的实现方案。硬件平台采用自行设计的以Motorola MC9328 MX1为核心的开发系统。该系统采用CPU内部LCD控制器和240×320分辨率的16 bpp TFT LCD作为显示设备，采用I2C总线扩展出16按键以及MX1集成的ASP模块和电阻触摸屏。操作系统为ARM Linux 2.4.18。

QtEmbedded 3.x版本系统中与底层硬件接口相关部分的源码位于srcembedded目标中。该部分包含三类设备的接口：framebufer、鼠标与键盘。参照该目标中相关设备的具体接口代码，根据自身硬件台增添接口即可。

由于系统LCD的岔道率为240×320，物理尺寸较小，在实现其于该系统的framebuffer驱动程序时并没有将其本身与Linux字符控制台设备挂靠，因此framebuffer并不具备TEXT模式的工作方式。在移植QtEmbedded时，无需作framebuffer设备的工作方式转换。正确配置色彩显示支持后，QtEmbedded能够在LCD显示出正确的图形。由于该平台的显示系统为纵向320行，在设计时考虑到人对于非手持设备的视觉习惯为宽度大于高度的观察方式，为了符合这种习惯性的观察方式，在移植QtEmbedded时采用了Transformed的旋转图形显示方式在软件上实现了显示方向的转换变化。

鼠标设备接口这一基类QWSMouseHandler的实现位于srcembeddedqmouse_qws.cpp中。与2.x版本系列不同的是，3.x中所有的Linux触摸屏示例接口代码均实现在srcembeddedqmouselinuxtp_qws.cpp中的QWSLinuxTPMouseHandler类中。其中对于不同型号的触摸屏的接口实现代码，采用不同的宏定义和预编译的方式将它们分隔开。笔者还通过从QWSLinuxTPMouseHandler中继承自身触摸屏接口类，替代原有的QWSLinuxTPMouseHandlerPrivate类，而在QWSLinuxTPMouseHandler生成自身触摸屏接口对象的方式，较好地将移植部分的代码与原有比较混乱的代码分隔开来。


   3.x中键盘接口基类们于srcembeddedqkbd_qws.cpp中，为QWSKeyboardHandler。实现I2C总线扩展出的16键键盘接口类方式与触摸屏类似，此处不多述。需要注意的是，QtEmbedded提供了事件过滤器（key event filter）的接口，在键盘点击事件从QWSServer截获并发送到相应的client之前会经过函数QWSServerKeyboardFilter。在此函数中可以按照自身需求生成新的键盘点击事件，而后利用QWSServersendKeyEvent()发送新的点击事件到client中。利用该方式可以将各种键盘点击无法输入的unicode字符转换出来，从而可以在较少的按键键盘上实现多unicode字符输入法。QtEmbedded 3.x键盘接口的移植与鼠标设备接口类似，此处不多述。 

3 总结

随着嵌入式处理器运算能力的不断提高，对外设支持的不断丰富，嵌入式Linux系统的应用也逐渐增多。QtEmbedded延续了Qt在桌面系统的所有功能，丰富的API接口和基于组件的编程模型使得嵌入式Linux系统中的应用程序开发更加便捷。由于QtEmbedded本身面向高端的手持设备和移动设备，将成为未来嵌入式系统的主要GUI。 
