#ifndef Q_APP_UTILITY_ENCRYPT_UTILITY_H_
#define Q_APP_UTILITY_ENCRYPT_UTILITY_H_



#if ( H_PROVIDE_NET_CA_ENCRYPT && H_PROVIDE_IDEA_ENCRYPT )

namespace ext
{
    class EncryptUtility
    {
    public:
        //! \brief IDEA encrypt
        //! \param const unsigned char * szSource - the input source data
        //! \param const unsigned int nSourceLen - the source data length
        //! \param const osl::StringA & strEncryptKey - the 16 bytes long encrypting key
        //! \param osl::MemoryDataStream & dataEncrypted - the encrypted data is stored here
        //! \return bool - true if encrypts successfully
        static bool ideaEncrypt( const unsigned char* szSource, const unsigned int nSourceLen, const osl::StringA& strEncryptKey, osl::MemoryDataStream& dataEncrypted );


        //! \brief 
        //! \param const char * vk - 
        //! \param const char * usr - 
        //! \param const char * pwd - 
        //! \param const char * op - 
        //! \param const char * host - 
        //! \param osl::StringA & output - 
        //! \return bool - 
        static bool getEncryptKeyFromCACenter(const char* vk, const char *usr, const char *pwd, const char *op, const char *host, osl::StringA& output)
        {/*{{{*/
            int i = 0;
            char *key[ME_CONF_MAX_LINE], *value[ME_CONF_MAX_LINE];
            char *url = NULL;
            long timeout = 0;

            for(i=0;i<ME_CONF_MAX_LINE;i++)
            {
                key[i] = (char *)malloc(ME_CONF_MAX_KEY_LEN);
                value[i] = (char *)malloc(ME_CONF_MAX_VALUE_LEN);
                if(key[i] == NULL || value[i] == NULL) return 1;
            }

            int line_count = GetConfig(key, value);
            if(line_count == 0)
            {
                for(i=0;i<ME_CONF_MAX_LINE;i++)
                {
                    free(key[i]);
                    free(value[i]);
                }
                return 1;
            }

            for(i=0;i<line_count;i++)
            {
                if(strncmp(key[i], "USER_VERIFY_INTF", 16) == 0)  url = value[i];
                if(strncmp(key[i], "REQ_TIMEOUT", 11) == 0) timeout = atoi(value[i]);
            }

            long http_code;
            int post_data_len = 0;
            char errmsg[ME_OUTPUT_ERRMSG_MAX_LEN];
            char post_data[ME_POST_DATA_MAX_LEN];
            char *ver = (char *)ccweb_get_info(handle);
            char vk[9];

            //get vk
            int get_ret = getVk(usr, pwd, op, host, vk);
            if( get_ret == 1)
            {
                for(i=0;i<ME_CONF_MAX_LINE;i++)
                {
                    free(key[i]);
                    free(value[i]);
                }
                fprintf(stderr, "ENGINE_GET_VK_FAILED for %s\n", usr);
                return 1;
            }

            post_data_len=28 + strlen(usr)+strlen(pwd)+strlen(op)+strlen(host)+strlen(ver)+8;
            if(post_data_len + 1 > ME_POST_DATA_MAX_LEN) return 1;

            sprintf(post_data, "usr=%s&pwd=%s&op=%s&host=%s&ver=%s&vk=%s", usr, pwd, op, host, ver, vk);

            fprintf(stderr, "url: [%s]\npost_data: [%s]\n", url, post_data);
            int cont_ret = SendReq(url, post_data, timeout, output, &http_code, errmsg);
            fprintf(stderr, "output:%s\n", output);

            for(i=0;i<ME_CONF_MAX_LINE;i++)
            {
                free(key[i]);
                free(value[i]);
            }

            if(cont_ret != 0 && http_code == 200)
            {
                return 0;
            }
            else
            {
                fprintf(stderr, "Req %s, http_code:%ld, errmsg:%s", url, http_code, errmsg);
            }

            return 1;
        }/*}}}*/

    };
} // end of namespace ext

#endif // end of #if ( H_PROVIDE_NET_CA_ENCRYPT && H_PROVIDE_IDEA_ENCRYPT )



#endif //end of #ifndef Q_APP_UTILITY_ENCRYPT_UTILITY_H_




